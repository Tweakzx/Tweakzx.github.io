<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='《AntMan: Dynamic Scaling on GPU Clusters for Deep Learning》论文阅读笔记 Abstract 如何在大规模GPU集群上有效调度深度学习工作， 对于工作性能，系统吞吐量和硬件利'><title>【论文笔记】AntMan论文阅读笔记</title>

<link rel='canonical' href='https://tweakzx.github.io/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0antman%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='【论文笔记】AntMan论文阅读笔记'>
<meta property='og:description' content='《AntMan: Dynamic Scaling on GPU Clusters for Deep Learning》论文阅读笔记 Abstract 如何在大规模GPU集群上有效调度深度学习工作， 对于工作性能，系统吞吐量和硬件利'>
<meta property='og:url' content='https://tweakzx.github.io/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0antman%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/'>
<meta property='og:site_name' content='Tweakzx'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='GPU虚拟化' /><meta property='article:published_time' content='2022-08-29T15:41:42&#43;08:00'/><meta property='article:modified_time' content='2022-08-29T15:41:42&#43;08:00'/><meta property='og:image' content='https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220829154241.png' />
<meta name="twitter:title" content="【论文笔记】AntMan论文阅读笔记">
<meta name="twitter:description" content="《AntMan: Dynamic Scaling on GPU Clusters for Deep Learning》论文阅读笔记 Abstract 如何在大规模GPU集群上有效调度深度学习工作， 对于工作性能，系统吞吐量和硬件利"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220829154241.png' />
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0antman%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">
                
                    <img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220829154241.png" loading="lazy" alt="Featured image of post 【论文笔记】AntMan论文阅读笔记" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E8%AE%BA%E6%96%87/" >
                论文
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0antman%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">【论文笔记】AntMan论文阅读笔记</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Aug 29, 2022</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    19 minute read
                </time>
            </div>
        
    </footer>
    
</div>

    

</header>

    <section class="article-content">
    <h1 id="antman-dynamic-scaling-on-gpu-clusters-for-deep-learning论文阅读笔记">《AntMan: Dynamic Scaling on GPU Clusters for Deep Learning》论文阅读笔记</h1>
<h2 id="abstract">Abstract</h2>
<ul>
<li>
<p>如何在大规模GPU集群上有效调度深度学习工作， 对于<strong>工作性能</strong>，<strong>系统吞吐量</strong>和<strong>硬件利用率</strong>至关重要。</p>
<ul>
<li>随着深度学习的工作量变得更加复杂，它变得越来越具有挑战性。</li>
</ul>
</li>
<li>
<p>本文将介绍Antman， 这是一种深入学习的基础设施，该基础架构共同设计了集群调度程序，并已在阿里巴巴部署在生产中，以管理数以万计的每日深度学习工作。</p>
<ul>
<li>Antman适应深度学习训练的波动资源需求。因此，它利用备用GPU资源在共享GPU上共同执行多个作业。</li>
<li>Antman利用深度学习训练的独特特征，在深度学习框架内为显存和计算资源引入动态缩放机制。这允许job之间的细粒度协调并防止工作干扰。</li>
<li>评估表明，Antman在我们的多租户集群中不损害公平性的情况下，整体将显存利用率提高了42％，计算资源利用率提高了34％，为有效利用大规模的GPU提出了新方法。</li>
</ul>
</li>
</ul>
<h2 id="introduction">Introduction</h2>
<ul>
<li>在共享多租户的DL集群， 许多工作排队等待资源的时候会导致GPU利用率低下，有两个原因
<ul>
<li>大多数的训练任务在执行过程中不能完全利用GPU资源
<ul>
<li>训练一个DL模型通常需要多种计算的混合</li>
<li>当使用分布式的训练的时候，90%的时间会被浪费到网络通信上</li>
</ul>
</li>
<li>基于资源预留的集群调度方案导致显著的GPU空闲，DL工作中总有部分资源没有投入使用
<ul>
<li>例如，随机梯度下降是同步的，需要获取所有的资源以进行gang-scheduling， 在得到所有资源之前，已得到的部分资源就会陷入空闲</li>
</ul>
</li>
</ul>
</li>
<li>在共享GPU上进行<strong>packing job</strong>
<ul>
<li>可以提高GPU的利用率，可以使得同样的集群整体上胜任更多的job。</li>
<li>但是这个策略在生产集群上很少使用， 原因
<ul>
<li>尽管提升GPU的利用率是有利的，但也要保证resource-guarantee jobs（RGJ，资源保证性job）的性能。同一个GPU上同时执行多个job会导致干扰&ndash;&gt;RGJ性能出现显著下降</li>
<li>job packing策略可以给并发job引入内存竞争。job需要的资源陡然增加的话，有可能导致训练任务failure。</li>
</ul>
</li>
<li>因此，job资源的独占分配在显存的GPU集群生产环境中比较典型</li>
</ul>
</li>
<li>我们提出AntMan
<ul>
<li>简述
<ul>
<li>一个DL系统提高GPU集群的利用率</li>
<li>同时保证公平性与RGJ的性能</li>
<li>通过合作性的资源扩缩来减少job干扰</li>
</ul>
</li>
<li>DL系统中引入了新的<strong>分配机制</strong>在job训练过程中来动态地精确分配所需资源（显存和计算单元）</li>
<li>使用<strong>超卖机制</strong>使得任何空闲的GPU资源（显存和计算单元）都能被利用</li>
<li>重新设计了<strong>集群调度器和DL框架</strong>来适应生产job的波动的资源特点
<ul>
<li>通过
<ul>
<li>框架信息感知调度</li>
<li>透明显存扩展</li>
<li>快速可持续的任务间协调</li>
</ul>
</li>
<li>使用这个结构，Antman为DL任务的同时执行的policy design 开辟了空间</li>
</ul>
</li>
<li>AntMan采用了简单且有效的策略来最大化集群吞吐
<ul>
<li>为RGJ提供资源保证的同时</li>
<li>分配一些偶然性的任务来尽力而为的利用GPU资源（低优先级且不保证资源）</li>
</ul>
</li>
</ul>
</li>
<li>本文主要贡献如下
<ul>
<li>对生产环境的DL集群进行调研，发现低利用率来自于三个方面：硬件，集群调度，job行为</li>
<li>在DL框架中为显存和计算单元管理引入了两种动态放缩机制，来解决GPU共享问题。新机制利用DL的工作特征来动态调整DL job的资源使用情况，在作业执行期间。</li>
<li>通过共同设计集群调度器和DL框架以利用动态缩放机制，我们为GPU共享引入了一种新的工业方法。这在多租户集群中维护工作服务级协议（SLA），同时通过机会调度来改善集群利用率。</li>
<li>在超过5000个GPU上进行了实验</li>
</ul>
</li>
</ul>
<h2 id="motivation">Motivation</h2>
<h3 id="deep-learning-training">deep learning Training</h3>
<ul>
<li>深度学习训练通常包括数百万次迭代，每个迭代过程都称为mini-batch。
<ul>
<li>通常，训练mini-batch可以分为三个阶段。
<ul>
<li>首先，计算样品和模型权重以产生一组得分，称为forward pass</li>
<li>其次，使用目标函数在产生的分数和所需的分数之间计算loss error。然后，损失通过模型向后扩散，以计算梯度，称为backward pass。</li>
<li>最后，通过由优化器定义的学习率来缩放梯度，以更新模型参数。</li>
</ul>
</li>
<li>正向通行的计算输出通常包括许多数据输出，每个数据输出称为张量。这些张量应暂时保存在内存中，并被向后通过以计算梯度。通常，为了监视培训中的模型质量，定期触发评估.</li>
</ul>
</li>
<li>为了使用大量数据培训模型，DL通常在多个GPU中采用数据并行性，其中每个GPU负责并行处理数据子集，同时在模型更新之前执行每个迷你批次梯度同步。</li>
<li>在大型公司中，多租户集群通常用于改善硬件利用率，用户有时可以超额订阅GPU资源配额，尤其是当GPU要求爆发时。</li>
</ul>
<h3 id="characterizing-production-dl-cluster">Characterizing Production DL Cluster</h3>
<p>我们从三个角度研究生产集群中的资源使用率：硬件，集群调度和job行为。</p>
<ul>
<li>
<p>在使用中的GPU的低利用率</p>
<ul>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220831200958.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220831200958.png"
			
			
			
			loading="lazy"
			alt="image-20220831200958715">
	</a>
	
	<figcaption>image-20220831200958715</figcaption>
	
</figure></li>
<li>内存容量。如图所示，只有20％的GPU正在运行消耗一半以上GPU存储器的应用程序。</li>
<li>关于计算单元的使用，只有10％的GPU获得了高于80％的GPU利用率。</li>
<li>该统计数据表明，GPU内存和计算单元均未得到充分利用，因此浪费了昂贵的硬件资源。</li>
</ul>
</li>
<li>
<p>对gang-schedule的空闲等待</p>
<blockquote>
<p>Gang scheduling是在并发系统中将多个相关联的进程调度到不同处理器上同时运行的策略，其最主要的原则是保证所有相关联的进程能够同时启动，防止部分进程的异常，导致整个关联进程组的阻塞。例如，您提交一个批量Job，这个批量Job包含多个任务，要么这多个任务全部调度成功，要么一个都调度不成功。这种All-or-Nothing调度场景，就被称作Gang scheduling。</p>
</blockquote>
<ul>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220831201016.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220831201016.png"
			
			
			
			loading="lazy"
			alt="image-20220831201015900">
	</a>
	
	<figcaption>image-20220831201015900</figcaption>
	
</figure></li>
<li>多GPU训练工作需要<strong>Gang scheduling</strong>，这意味着除非同时提供所有必需的GPU，否则job将不会开始训练</li>
<li>由于GPU资源往往不能同时全部获得， 所以会出现<strong>idle waiting</strong>。 一个job需要的GPU越多， 它的平均闲置时间就越长</li>
<li>**资源到达的不可预测导致了预留资源的idle waiting。**一个幼稚的解决方案是在GPU idle waiting的时候执行别的job。但是这会导致资源需求大job的饥饿，影响分配公平性。另外一旦资源需要被满足导致的GPU需求激增或许导致GPU之间的资源冲突，导致工作fail</li>
</ul>
</li>
<li>
<p>动态资源需求</p>
<ul>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220831201048.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220831201048.png"
			
			
			
			loading="lazy"
			alt="image-20220831201047910">
	</a>
	
	<figcaption>image-20220831201047910</figcaption>
	
</figure></li>
<li>在一个DL job生命周期中， GPU资源往往未被充分利用。</li>
<li>图3：在Criteo数据集上运行DEEPFM [20]时的前10分钟。一开始，数据集上的预处理仅需要CPU。但是，GPU的SM利用率和内存使用量在275秒时启动。</li>
<li>图4：训练可以包含几个阶段，不同阶段的SM和Memory的使用率都是不一样的</li>
<li>资源需求的动态变化与固定的资源分配和漫长的训练时间相矛盾。资源需要满足job的峰值需要，导致这个昂贵的硬件被低效利用。显存的DL框架的memory caching设计隐藏了显存使用随时间的变化，一定程度上阻止了GPU的潜在共享。</li>
</ul>
</li>
</ul>
<h3 id="opportunities-in-dl-uniqueness">Opportunities in DL Uniqueness</h3>
<ul>
<li>
<p>超卖有<strong>机会</strong>提高集群的吞吐</p>
<ul>
<li>不可预测的job内和job间的需求激增为安全的资源共享引入了挑战
<ul>
<li>因为资源竞争， jobs可能会把显存用光</li>
<li>在多租户集群中，当jobs在共享环境执行时，为持有定额资源的job提供性能隔离是十分重要的</li>
</ul>
</li>
<li>AntMan利用DL training的特性来利用这个机会</li>
</ul>
</li>
<li>
<p>我们在生产环境集群的10k个task中取样发现</p>
<ul>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905143626.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905143626.png"
			
			
			
			loading="lazy"
			alt="image-20220905143619325">
	</a>
	
	<figcaption>image-20220905143619325</figcaption>
	
</figure></li>
<li>只有一小部分用来存储模型， 且90%的模型大小不超过500M</li>
<li>大部分显存在同一个mini-batch中被分配和释放</li>
<li>除此之外，一个mini-batch的消耗时间很短， 80%的任务在600ms之内消耗一个mini-batch</li>
</ul>
</li>
<li>
<p>我们通过多种方式利用这种独特的特征来安排共享GPU上的作业。</p>
<ul>
<li>首先，根据通常的模型大小，大部分显存在共同执行的作业中可以拿来调度</li>
<li>其次，mini-batch的周期通常很短，可以在每个mini-batch边界处进行细粒度的GPU内存和计算资源的调度。这可以进一步允许job间的快速资源协调。</li>
<li>第三，mini-batch通常进行相似的计算，这可以被利用去描述job性能，因此进度率可以被创建作为性能矩阵来量化干扰。</li>
</ul>
</li>
</ul>
<h2 id="design">Design</h2>
<p>AntMan深入共同设计集群调度程序和DL框架， 本部分将介绍三部分：DL 框架的修改，调度器与调度原则</p>
<h3 id="dynamic-scaling-in-dl-frameworks">Dynamic Scaling in DL Frameworks</h3>
<ul>
<li>低使用效率的GPU集群有着执行更多任务的潜力，但需要解决一下挑战
<ul>
<li>使用最下需求执行job的同时防止GPU内存使用的爆发导致的失效</li>
<li>适应计算单元的使用波动的同时限制潜在的干扰</li>
</ul>
</li>
<li>DL框架是专注于GPU执行， 缺乏job合作的能力。这激发了动态缩放机制的设计，机制包含内存和计算两部分</li>
</ul>
<h4 id="memory-management">Memory Management</h4>
<p>AntMan以tensor为单位，在GPU和CPU的内存间进行动态内存管理。类似于操作系统的虚拟内存，AntMan以tensor为单位进行了显存虚拟化，通过这种方式，DL框架可以提供超出上限的显存。</p>
<ul>
<li>
<p>显存分配</p>
<ul>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905151151.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905151151.png"
			
			
			
			loading="lazy"
			alt="image-20220905151151692">
	</a>
	
	<figcaption>image-20220905151151692</figcaption>
	
</figure></li>
<li>在张量被销毁后，GPU内存被缓存在DL框架内的一个全局内存分配器中，普遍情况下，一些张量只在DL训练的某些阶段使用（如数据预处理、评估），不再需要了。然而，这部分缓存的GPU内存不会被释放（图6c）。DL框架中的这种缓存内存设计优化了单个作业的性能，但代价是失去了共享潜力。</li>
<li>AntMan转向了扩展GPU内存上限的方法。它主动检测使用中的内存，以缩小缓存的内存，从而自省地将GPU内存的使用调整合适。这是通过监测应用性能和处理小批量时的内存需求来实现的（图6d）。<strong>AntMan使用其最大的努力在GPU设备上分配张量，然而，如果GPU内存仍然缺乏，张量可以在GPU之外用主机内存分配</strong>（图6e）。当GPU内存的上限增加时，Tensors可以自动分配回GPU（图6f）。</li>
</ul>
</li>
<li>
<p>显存上限动态调整</p>
<ul>
<li>
<p><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905151235.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905151235.png"
			
			
			
			loading="lazy"
			alt="image-20220905151235705">
	</a>
	
	<figcaption>image-20220905151235705</figcaption>
	
</figure></p>
</li>
<li>
<p>图7a说明了内存扩展<strong>如何解决突发需求</strong>。在T0，正在运行的DL训练作业的内存需求增加，由于GPU内存的有限上限，一些张量不能放在GPU内存中，而是使用主机内存创建。AntMan检测到主机内存的使用情况，在T1，它根据主机内存的使用<strong>情况提高该作业的GPU内存的上限</strong>，虽然在这一个小批次中，这个运行作业的性能可能会减慢，因为张量被放置在主机内存中，<strong>但是后续的tensor都会申请到显存上</strong>。考虑到一个典型的DL训练往往需要数百万个小批次，这种性能开销是可以忽略不计的。</p>
</li>
</ul>
</li>
<li>
<p>运行时显存细粒度调整</p>
<ul>
<li>此外，AntMan在<strong>运行时</strong>提供细粒度的GPU内存调度。如图7b所示，一个训练作业可能会收缩以确保其他作业的内存资源，并在其他作业完成后再增长。它说明了一个DL作业在T0时缩减，在T1时增加，代价是在主机内存上分配了一些张量。因此，在同一共享GPU中运行的作业在T0和T1之间对剩余GPU内存的使用是有保障的。</li>
</ul>
</li>
</ul>
<h4 id="computation-management">Computation Management</h4>
<ul>
<li>动态计算单元管理，用于控制DL训练作业的GPU利用率。
<ul>
<li>
<p>类似cgroup，可以在运行时动态地隔离DL特定进程的GPU计算资源访问。</p>
</li>
<li>
<p>当多个DL作业在同一个GPU上启动时，干扰主要是由<strong>潜在的GPU内核排队延迟</strong>和<strong>PCIe总线争用</strong>引起的，这会导致所有作业的性能一致下降，如果packing job是在相同的模型和配置上运行的话。</p>
</li>
<li>
<p>**如果不同的作业被打包在一起，作业会以不同的方式变慢。**这是因为作业在获取GPU计算单元方面有不同的能力。因此，作业性能在GPU共享中几乎无法保证或预测，导致多租户集群的GPU共享部署困难。</p>
</li>
<li>
<p>AntMan中，GPU运算器的执行是由一个新引入的模块负责的，称为GpuOpManager。</p>
<ul>
<li>当GPU运算器准备执行时，它被添加到GpuOpManager，而不是直接启动。</li>
<li>GpuOpManager的主要思想是通过<strong>延迟执行GPU运算符来控制启动频率</strong>。GpuOpManager通过这种方式来限制DL训练作业的GPU利用率。GpuOpManager不断对GPU运算器的执行时间进行分析，并在启动GPU运算器之前简单地分配空闲的时间段。</li>
<li>请注意，GpuOpManager只是延迟了GPU内核的执行。因此，运算符（包括GPU运算符和CPU运算符）之间的潜在依赖关系被保留下来，这意味着如果可能的话，CPU运算符可以继续。</li>
</ul>
</li>
<li>
<p><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905151223.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905151223.png"
			
			
			
			loading="lazy"
			alt="image-20220905151222951">
	</a>
	
	<figcaption>image-20220905151222951</figcaption>
	
</figure></p>
<blockquote>
<p>图8说明了在同一GPU上执行的两个作业的GPU计算单元干扰的例子。图8a说明了Job-A是如何以细粒度的方式在GPU上执行的。简而言之，GPU内核将被按顺序放置，并由GPU计算单元逐一处理。请注意，在图8中，Job-A可能无法使GPU完全饱和，导致GPU周期闲置，GPU利用率低，有可能被其他作业使用。</p>
<p>因此，作业-B被安排在这个GPU上（图8b）。Job-B的GPU操作者启动在GPU中执行的内核（绿色块），这可以填满它，从而延迟其他GPU内核（蓝色块）的执行，导致Job-A的性能不佳。</p>
<p>这种干扰主要来自于缺乏控制GPU内核执行频率的能力。为了解决这个问题，我们在DL框架中引入了一个GPU运算器管理器（图8c）。</p>
<p>现有的DL框架一旦满足了GPU运算器的控制依赖性，就会在GPU运算器中发布GPU内核。在如图8c所示，第三个CPU操作符没有被阻止，然而，第四个操作符被延迟了，因为它依赖于第二个GPU操作符，它的执行被GpuOpManager延迟了。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="collaborative-scheduler">Collaborative Scheduler</h3>
<ul>
<li>
<p>AntMan的整体架构</p>
<ul>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905152947.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905152947.png"
			
			
			
			loading="lazy"
			alt="image-20220905152947633">
	</a>
	
	<figcaption>image-20220905152947633</figcaption>
	
</figure></li>
<li>AntMan采用了一个分层结构
<ul>
<li>一个全局调度器负责job 调度</li>
<li>每个工作服务器都包含一个本地协调器，负责通过考虑DL框架报告的统计数据，使用动态资源扩展的基元管理作业的执行</li>
</ul>
</li>
<li>AntMan是为多租户GPU集群设计的。
<ul>
<li>在多租户集群中，每个租户通常拥有一定的资源，被注释为资源配额（即GPU的数量），这是可以分配给该租户的作业的并发性能保证资源。</li>
<li>每个租户的GPU资源配额之和小于等于一个GPU集群的总容量。</li>
</ul>
</li>
<li>在AntMan中，工作被分为两种，由全局调度器应用不同的调度策略
<ul>
<li>资源保证型工作：资源保障型作业会消耗其相应租户的一定数量的GPU资源配额。AntMan确保资源保证作业的性能应该与独占执行的性能一致。</li>
<li>机会型工作：机会型作业则不会。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>AntMan各模块的运作方式</p>
<ul>
<li>调度决策可以被视为一个<strong>自上而下</strong>的控制流
<ul>
<li>在AntMan中，与传统的集群调度器类似，调度决策由全局调度器派发给本地协调器</li>
<li>本地协调器使用动态缩放机制对GPU资源进行内省式调度，以达到DL训练作业的目的</li>
</ul>
</li>
<li>数据统计流信息由<strong>本地协调器的统计模块收集</strong>，并以<strong>自下而上</strong>的方式汇总到<strong>集群统计模块</strong>上
<ul>
<li>信息
<ul>
<li>硬件信息
<ul>
<li>GPU利用率</li>
<li>GPU内存使用率</li>
</ul>
</li>
<li>DL框架报告的详细作业信息
<ul>
<li>小型批次持续时间</li>
<li>峰值内存使用率</li>
<li>最小内存使用率</li>
<li>主机内存消耗等</li>
</ul>
</li>
</ul>
</li>
<li>这些信息可以帮助全局调度器做出作业调度决策
<ul>
<li>峰值内存和最小内存使用量是用来指示可以快速提供的GPU内存大小</li>
<li>批处理时间显示GPU内存多久可以用于另一个DL训练作业</li>
</ul>
</li>
</ul>
</li>
<li>当作业在GPU服务器上启动，本地调度器管理其端到端执行
<ul>
<li>由于DL训练作业的负载波动，本地协调器以<strong>自省</strong>(introspective)的方式行事，对DL框架进行持续的作业控制</li>
<li>它从硬件和DL框架中收集所有作业的统计数据 -&gt; 使用我们在第3.1节中介绍的新原语 &ndash;&gt; 通过资源使用调整（例如，收缩GPU内存）&ndash;&gt; 来控制作业性能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="scheduling-policy">Scheduling Policy</h3>
<ul>
<li>
<p>目标</p>
<blockquote>
<ul>
<li>由于集群上的负载和作业的资源需求不断波动，在<strong>提供公平性</strong>（如确保DL作业的SLA，保证资源）和<strong>实现高资源利用率</strong>（如GPU利用率）之间存在着固有的矛盾。</li>
<li>普遍的生产型DL集群调度器经常以某些方式<strong>用公平性换取效率</strong>。
<ul>
<li>例如，空闲资源被分配给超额配置的租户。</li>
<li>然而，这样的GPU资源在没有抢占的情况下很难拿回来。一般来说，抢占很少被使用，因为它使正在运行的作业失败，同时浪费了昂贵的GPU周期。</li>
<li>此外，还报告了歧视大型作业的失序行为（即分配更多的GPU），导致倾向于小型作业的不公平。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>首要目标：多租户<strong>公平性</strong>
<ul>
<li>AntMan通过在全局调度器和本地协调器中实施的政策实现了公平性</li>
<li>这些政策由动态扩展机制提供支持。</li>
</ul>
</li>
<li>第二优先：<strong>提高集群效率</strong>，从而实现更高的吞吐量
<ul>
<li>AntMan中还引入了GPU机会主义工作，以窃取GPU中的空闲周期，从而最大限度地提高集群的利用率。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>全局调度器：维护着工作到达的多个租户队列，决定为工作分配的GPU的位置</p>
<ul>
<li>
<p>调度策略</p>
<ul>
<li>对于资源保证型工作和机会型工作，AntMan应用不同的调度策略，如算法1所示。</li>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905153001.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905153001.png"
			
			
			
			loading="lazy"
			alt="image-20220905153001724">
	</a>
	
	<figcaption>image-20220905153001724</figcaption>
	
</figure></li>
<li>findNodes是一个函数，它返回满足工作请求的节点和GPU候选者，并有一个可选的参数来指定约束。</li>
<li>全局调度器在<strong>有足够的GPU资源的情况下</strong>公平地分配资源保证作业。</li>
<li>除此之外，资源保证作业还可以<strong>使用空闲的GPU资源</strong>来最大化作业性能 。</li>
<li>如果一个作业的资源请求只能部分满足，全局调度器就会为这个作业<strong>保留资源</strong>。</li>
<li>保留的资源将永远不会被其他资源保证的作业占用，但是它们可以被<strong>机会主义作业</strong>所利用。</li>
</ul>
</li>
<li>
<p>机会主义作业</p>
<ul>
<li>默认情况下，全局调度器将估计没有设置GPU配额的作业的<strong>排队时间</strong>。排队时间长的作业将被<strong>自动</strong>作为机会主义作业执行。</li>
<li>目的：为了最大限度地利用自由资源。</li>
<li>它通过考虑<strong>实际的GPU利用率</strong>在GPU上分配机会主义作业。只有在过去10秒内利用率**低于M（目前设定为80%）**的GPU可以被选为候选。</li>
<li>在<strong>最空闲的候选人上分配机会主义作业</strong>（即minLoadNodes，第9-10行）。</li>
<li>分配在同一个GPU上的作业由<strong>本地协调者</strong>管理</li>
</ul>
</li>
<li>
<p>AntMan<strong>默认</strong>会自动选择机会主义作业，但它也允许用户在提交时<strong>手动</strong>确定作业类型</p>
<ul>
<li>明确指定为资源保证作业，以确保SLA</li>
<li>一个作业也可以被指定为机会主义作业，永远不会占用租户的资源配额</li>
</ul>
<blockquote>
<p>在实践中，用户通常以机会主义模式提交作业，以避免潜在的排队延迟，目的是进行调试和超参数调整，这都是由早期反馈驱动的。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>本地调度器：协作执行共享GPU上的作业</p>
<ul>
<li>
<p>如何在共享执行中确保资源保证作业的性能</p>
<ul>
<li><strong>一个GPU只会分配给一个资源保证作业</strong>，因为它消耗GPU配额</li>
<li>本地协调者首先限制机会主义工作使用GPU，<strong>防止资源保证工作受到干扰</strong></li>
<li>在启动DL训练作业时，需要由DL框架初始化GPU设备
<ul>
<li>如果GPU处于高负荷状态，则需要更多时间。（初始化时占用更多资源）</li>
<li>一旦资源保证作业稳定执行，本地协调器将把剩余的GPU内存分配给机会主义作业。</li>
</ul>
</li>
<li>通过监测作业性能（即小批量时间），在不干扰资源保证作业的情况下，逐步增加机会主义作业的GPU计算单元使用量</li>
<li>同样，当一个机会主义作业到达共享GPU时，本地协调器在不影响资源保证作业的情况下，以阶梯式的方式提高其GPU资源使用率。</li>
</ul>
</li>
<li>
<p>如何处理资源保证作业的资源需求激增</p>
<ul>
<li>为了意识到动态的资源需求，本地协调器监测DL框架报告的指标</li>
<li>当一个资源保证作业增加了GPU内存需求时，由于有了通用内存，张量被暂时使用主机内存存储。</li>
<li>本地协调者缩减其他机会主义作业的GPU内存使用量，并提高资源保证作业的GPU内存限制，以恢复其性能。</li>
<li>这对GPU计算单元的使用协调是类似的。</li>
<li>🚨AntMan依靠应用层面的指标（即迷你批处理时间）来表明资源保证作业的性能。如果它观察到资源保证作业的性能不稳定，它就会采取悲观的策略来限制其他机会主义作业对GPU资源的使用。</li>
</ul>
</li>
<li>
<p>当一个GPU只被机会主义工作所共享时，最大限度地提高聚合工作的性能。</p>
<ul>
<li>
<p>如果只有一个机会主义作业，那么GPU资源就可以被这个作业充分利用，而没有任何约束。</p>
</li>
<li>
<p>有时，一个GPU有可能被多个机会主义工作占用。</p>
<ul>
<li>
<p>AntMan通过<strong>最大限度地提高GPU内存效率</strong>来优化聚合作业的性能。</p>
</li>
<li>
<p>在启用<strong>动态缩放机制</strong>后，我们发现不同的工作负载在内存限制带来的性能下降方面表现出<strong>不同的敏感性</strong></p>
<blockquote>
<ul>
<li>
<p><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905153042.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220905153042.png"
			
			
			
			loading="lazy"
			alt="image-20220905153042457">
	</a>
	
	<figcaption>image-20220905153042457</figcaption>
	
</figure></p>
</li>
<li>
<p>如图10所示，</p>
<ul>
<li>SR模型即使在其设备内存减少90%的情况下，也只遭受了大约25%的性能下降</li>
<li>Cifar10数据集上的VGG16[43]模型（VGG）即使在设备内存减少一半后，也能保持其大部分的原始性能。</li>
<li>ImageNet数据集（ResNet）上的ResNet50[22]对内存缩减很敏感；10%的内存缩减会带来60%以上的速度下降。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>当机会主义作业的总的GPU内存需求超过了GPU的内存容量时</p>
<ul>
<li>将GPU内存分配给最能提高作业性能（Normalized Performance）的作业</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Job 升级</p>
<ul>
<li>机会主义工作虽然以best effort执行， 但这是在没有SLA保证的情况下。</li>
<li>全局调度器会在有足够资源的情况下<strong>升级</strong>这些作业，以快速完成它们。</li>
<li>全局调度器通知本地协调器，将其<strong>标记</strong>为资源保证作业，并消耗租户的GPU配额来完成作业升级。</li>
</ul>
<blockquote>
<ul>
<li>对于分布式同步DL训练来说，部分升级没有帮助，因为一个工作者的性能下降可能会广播到整个作业。</li>
<li>因此，全局调度器检查所有GPU是否都被机会主义工作填满。</li>
<li>一旦所有的任务实例都准备好升级，并且资源配额足够，AntMan更愿意将机会主义工作升级，而不是新启一个工作。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="implementation">Implementation</h2>
<h3 id="deep-learning-framework">Deep Learning Framework</h3>
<ul>
<li>动态缩放机制在两个流行的深度学习框架中实现
<ul>
<li>Pytorch</li>
<li>Tensorflow</li>
</ul>
</li>
<li>DL框架的修改主要体现在三个部分：
<ul>
<li>内存分配器
<ul>
<li>为了实现动态的通用内存，(tensorflow ::<strong>BFCAllocator</strong>, PyTorch::<strong>CUDACachingAllocator</strong>）被修改以引入可调整的内存上限。内存分配器会跟踪内存分配的总字节数，并在总字节数超过上限时触发内存不足。</li>
<li>此外，还为内存分配器引入了一个新的接口，允许在任何时候清空缓存内存。</li>
<li>还增加了一个新的通用内存分配器<strong>UniversalAllocator</strong>，以包裹GPU内存分配器和主机内存分配器（即使用cudaHostMalloc进行内存分配）。
<ul>
<li>当张量的请求触发了内存分配时，UniversalAllocator试图使用GPU内存分配器来分配内存，</li>
<li>如果GPU内存剩余不足，则将CPU内存分配器作为备份。</li>
<li>🚨UniversalAllocator维护了一个集合数据结构，记录了由GPU分配的内存区域的指针，用来对内存指针进行分类，以便于回收。</li>
</ul>
</li>
</ul>
</li>
<li>执行器
<ul>
<li>为了实现动态计算单元的扩展，在DL框架中引入了一个带有运算器处理队列的<strong>GpuOpManager</strong>，它在一个独立的线程中运行。</li>
<li>TensorFlow的运算器被相应地修改，以插入GPU Op到GpuOpManager队列中，从而将GPU运算器的执行专门交给它。</li>
<li>GpuOpManager可能会<strong>根据计算能力的有限百分比</strong>来延迟GPU运算符的实际执行。</li>
</ul>
</li>
<li>接口</li>
</ul>
</li>
<li>内存使用模式的统计数据和执行信息被汇总到本地协调器上
<ul>
<li>DL框架和本地协调器<strong>通过文件系统进行通信</strong></li>
<li>他们都有一个监控线程来检查文件，以接收工作统计数据或控制信号</li>
<li>为了最大限度地减少内存管理的开销，内存的动态缩放是在mini-batch的边界（session.run()的结束）触发的</li>
</ul>
</li>
</ul>
<h3 id="cluster-scheduler">Cluster Scheduler</h3>
<ul>
<li>在Kubernetes上实现了一个自定义调度器，作为评估AntMan的原型。
<ul>
<li>Kubernetes负责集群管理和执行Docker容器中的作业。</li>
<li>我们的<strong>全局调度器使用Python APIs来监控</strong>Kubernetes的API服务器中的事件，以便进行调度。</li>
<li><strong>本地协调器作为DaemonSet部署</strong>在Kubernetes中。每个协调器监控文件系统的某些路径，以收集每个作业的报告信息。</li>
<li>汇总的作业和设备<strong>信息存储在ETCD中</strong>，这是Kubernetes中内置的分布式键值存储。因此，全局调度器在做调度决策时直接读取ETCD中的状态。</li>
</ul>
</li>
</ul>
<h2 id="evaluation">Evaluation</h2>
<h3 id="benchmark">Benchmark</h3>
<h3 id="trace-experiment">Trace Experiment</h3>
<h3 id="cluster-experiment">Cluster Experiment</h3>
<h2 id="ralated-work">Ralated Work</h2>
<h2 id="conclusion">Conclusion</h2>
<p>参考资料</p>
<ul>
<li>论文地址：<a class="link" href="https://www.usenix.org/conference/osdi20/presentation/xiao"  target="_blank" rel="noopener"
    >AntMan: Dynamic Scaling on GPU Clusters for Deep Learning | USENIX</a></li>
<li>代码地址：https://github.com/alibaba/GPU-scheduler-for-deep-learning</li>
<li>参考：<a class="link" href="http://gaocegege.com/Blog/kubernetes/antman"  target="_blank" rel="noopener"
    >OSDI'20 论文赏：ANTMAN: DYNAMIC SCALING ON GPU CLUSTERS FOR DEEP LEARNING | 高策 (gaocegege.com)</a></li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/gpu%E8%99%9A%E6%8B%9F%E5%8C%96/">GPU虚拟化</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="has-image">
    <a href="/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0gaiagpu%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220826142857.png" loading="lazy" data-key="" data-hash="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220826142857.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【论文笔记】GaiaGPU论文阅读笔记</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0tgs%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202305081343395.png" loading="lazy" data-key="" data-hash="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202305081343395.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【论文笔记】TGS论文阅读笔记</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/doing/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0dnn%E8%AE%AD%E7%BB%83%E8%B4%9F%E8%BD%BD%E5%88%86%E6%9E%90/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202302131401477.png" loading="lazy" data-key="" data-hash="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202302131401477.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【论文笔记】DNN训练负载分析</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0harmony%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202301041018146.png" loading="lazy" data-key="" data-hash="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202301041018146.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【论文笔记】Harmony论文阅读笔记</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0tiresias%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202212270951184.png" loading="lazy" data-key="" data-hash="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202212270951184.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【论文笔记】Tiresias论文阅读笔记</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <script
    src="https://giscus.app/client.js"
    data-repo="Tweakzx/Tweakzx.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkzMjY5MTY1NTE="
    data-category="Announcements"
    data-category-id="DIC_kwDOE3xZx84CTfL-"
    data-mapping="title"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light_tritanopia"
    crossorigin="anonymous"
    async
></script>
<script>
    function setGiscusTheme(theme) {
        let giscus = document.querySelector('iframe.giscus-frame');
        if (giscus) {
            giscus.contentWindow.postMessage(
                { 
                    giscus: {
                        setConfig: { 
                            theme: theme 
                        }
                    }
                },
                "https://giscus.app"
            );
        };
    };

    (function(){
        addEventListener('message', (e) => {
            if (event.origin !== 'https://giscus.app') return;
            handler()
        });
        window.addEventListener('onColorSchemeChange', handler);

        function handler() {
            if (document.documentElement.dataset.scheme === "light") {
                setGiscusTheme('light_tritanopia');
            } else {
                setGiscusTheme('dark_tritanopia');
            };
        };
    }());
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2023 Tweakzx
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.5.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#abstract">Abstract</a></li>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#motivation">Motivation</a>
      <ol>
        <li><a href="#deep-learning-training">deep learning Training</a></li>
        <li><a href="#characterizing-production-dl-cluster">Characterizing Production DL Cluster</a></li>
        <li><a href="#opportunities-in-dl-uniqueness">Opportunities in DL Uniqueness</a></li>
      </ol>
    </li>
    <li><a href="#design">Design</a>
      <ol>
        <li><a href="#dynamic-scaling-in-dl-frameworks">Dynamic Scaling in DL Frameworks</a>
          <ol>
            <li><a href="#memory-management">Memory Management</a></li>
            <li><a href="#computation-management">Computation Management</a></li>
          </ol>
        </li>
        <li><a href="#collaborative-scheduler">Collaborative Scheduler</a></li>
        <li><a href="#scheduling-policy">Scheduling Policy</a></li>
      </ol>
    </li>
    <li><a href="#implementation">Implementation</a>
      <ol>
        <li><a href="#deep-learning-framework">Deep Learning Framework</a></li>
        <li><a href="#cluster-scheduler">Cluster Scheduler</a></li>
      </ol>
    </li>
    <li><a href="#evaluation">Evaluation</a>
      <ol>
        <li><a href="#benchmark">Benchmark</a></li>
        <li><a href="#trace-experiment">Trace Experiment</a></li>
        <li><a href="#cluster-experiment">Cluster Experiment</a></li>
      </ol>
    </li>
    <li><a href="#ralated-work">Ralated Work</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
