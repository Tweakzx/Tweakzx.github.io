<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='论文阅读'><title>GaiaGPU 论文阅读笔记</title>

<link rel='canonical' href='https://tweakzx.github.io/p/gaiagpu-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='GaiaGPU 论文阅读笔记'>
<meta property='og:description' content='论文阅读'>
<meta property='og:url' content='https://tweakzx.github.io/p/gaiagpu-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/'>
<meta property='og:site_name' content='Tweakzx'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='GPU虚拟化' /><meta property='article:tag' content='K8s' /><meta property='article:published_time' content='2022-08-26T17:20:32&#43;08:00'/><meta property='article:modified_time' content='2022-08-26T17:20:32&#43;08:00'/><meta property='og:image' content='https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220826142857.png' />
<meta name="twitter:title" content="GaiaGPU 论文阅读笔记">
<meta name="twitter:description" content="论文阅读"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220826142857.png' />
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/gaiagpu-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">
                
                    <img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220826142857.png" loading="lazy" alt="Featured image of post GaiaGPU 论文阅读笔记" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E8%AE%BA%E6%96%87/" >
                论文
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/gaiagpu-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">GaiaGPU 论文阅读笔记</a>
    </h2>

    
    <h3 class="article-subtitle">
        论文阅读
    </h3>
    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Aug 26, 2022</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    2 minute read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h2 id="gaiagpusharing-gpus-in-container-clouds论文笔记">《GaiaGPU：Sharing GPUs in Container Clouds》论文笔记</h2>
<h3 id="abstract">Abstract</h3>
<ul>
<li>对于云服务的提供商， 如何在容器间共享GPU， 是一个有吸引力的问题
<ul>
<li>容器的轻量与伸缩性</li>
<li>GPU强大的并行计算能力</li>
<li>在云环境，容器需要使用一个或多个GPU来满足资源需要的同时， 容器独占式的GPU往往使用率很低</li>
</ul>
</li>
<li>我们提出GaiaGPU，能够在容器间共享显存和算力
<ul>
<li>将物理GPU划分为多个虚拟GPU</li>
<li>采用<strong>弹性资源分配</strong>和<strong>动态资源分配</strong>来提高资源利用率</li>
<li>实验结果显示， 有效的实现了容器间资源的分配和隔离的同时，平均只增加了1.015%的开销。</li>
</ul>
</li>
</ul>
<h3 id="introduction">Introduction</h3>
<ul>
<li>容器化是一种虚拟化技术
<ul>
<li>涉及到量身定制一个标准操作系统，方便它在一个物理机上运行由多个用户处理的不同应用程序</li>
<li>与VM模拟底层硬件不同
<ul>
<li>容器模拟的是操作系统</li>
<li>轻量，可伸缩，易部署</li>
<li>微服务打包与发布应用的事实标准</li>
</ul>
</li>
<li>云服务提供商整合容器编排框架（如k8s）到基础架构中来提供容器云</li>
</ul>
</li>
<li>GPU 图像处理单元
<ul>
<li>有很强的并行处理能力
<ul>
<li>因为一个芯片上集成了数以千计的计算核</li>
<li>GPU被广泛用于计算密集型任务，以加快计算</li>
<li>随着技术的发展趋势，现代GPU内将集成入越来越多的计算资源</li>
</ul>
</li>
<li>CUDA是多功能GPU最流行的平台，提供了API方便GPU的使用</li>
<li>卓越的性能吸引了很多云提供商将GPU引入云环境
<ul>
<li>在云环境中，部署在容器中的一个应用程序可能需要一个或多个GPU才能执行，</li>
<li>而另一方面，应用程序的专用GPU资源导致资源不足。</li>
<li>因此，如何在不同的容器中共享GPU对大多数云提供商都非常感兴趣</li>
</ul>
</li>
</ul>
</li>
<li>GPU虚拟化技术是在隔离的虚拟环境（例如VM， 容器）之间共享GPU的技术
<ul>
<li>多数的GPU虚拟化技术应用于VM， 容器间的虚拟化技术还在起始阶段</li>
<li>现阶段的基于容器的GPU虚拟化技术有以下<strong>局限性</strong>
<ul>
<li>需要特定的硬件设备（NVIDIA GRID）</li>
<li>将一整个GPU分配给单个容器， 不能共享 （NVIDIA Docker）</li>
<li>容器间只能共享GPU显存 （ConvGPU）</li>
<li>只支持单个GPU （ConvGPU）</li>
</ul>
</li>
</ul>
</li>
<li>我们提出GaiaGPU，能够在容器间透明地共享显存和算力
<ul>
<li>用户不用修改容器镜像来共享底层GPU
<ul>
<li>我们使用k8s的device plugin 框架将物理GPU划分为多个虚拟GPU</li>
</ul>
</li>
<li>每个镜像可以按需分配一个或者多个vGPU</li>
<li>提供了两者方式在运行时更改镜像资源
<ul>
<li>弹性资源分配：暂时改变资源</li>
<li>动态资源分配：永久改变资源</li>
</ul>
</li>
</ul>
</li>
<li>vGPU包括GPU显存和计算资源
<ul>
<li>共享显存
<ul>
<li>容器包含GPU显存的一小部分</li>
<li>vGPU分配的是GPU的物理内存</li>
</ul>
</li>
<li>共享计算资源
<ul>
<li>共享计算资源意味着每个容器都拥有GPU线程的一部分以并行执行计算。</li>
<li>VGPU的计算资源由GPU的利用率衡量（采样时段内， 容器使用GPU的时间比例）</li>
</ul>
</li>
</ul>
</li>
<li>总结：本文做了如下贡献
<ul>
<li>提出了GaiaGPU：一种在容器间透明共享显存与算力的方法</li>
<li>采用弹性分配和动态分配的方式提高了资源的利用率</li>
<li>进行了四个实验来验证GaiaGPU的性能。结果：实现了容器间资源的分配和隔离的同时，平均只增加了1.015%的开销。</li>
</ul>
</li>
</ul>
<h3 id="related-work">Related Work</h3>
<h4 id="gpu虚拟化">GPU虚拟化</h4>
<ul>
<li>
<p>被应用于在多个虚拟环境之间分享GPU， 极大地提高了应用性能</p>
</li>
<li>
<p>现存的多数GPU虚拟化技术基于VM，主要有三种虚拟化GPU</p>
<ul>
<li>API remoting
<ul>
<li>vCUDA 和 rCUDA</li>
<li>创建GPU的封装库-&gt;劫持GPU调用-&gt;将重定向到host</li>
</ul>
</li>
<li><a class="link" href="https://www.geeksforgeeks.org/difference-between-full-virtualization-and-paravirtualization/"  target="_blank" rel="noopener"
    >para and full  virtualization</a>
<ul>
<li>GPUvm</li>
<li>GPUvm将GPU显存和MMIO（存储器映射输入输出）分成几片，将片分给VM</li>
</ul>
</li>
<li>硬件支持的虚拟化
<ul>
<li>NVIDIA GRID</li>
<li>硬件虚拟化，创建虚拟GPU，挂在容器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>与VM相比， 容器使用主机的操作系统-&gt;容器可以直接使用宿主机的GPU驱动-&gt;性能接近原生环境</p>
<ul>
<li>NVIDIA GRID
<ul>
<li>需要特定的硬件和与虚拟GPU要有相同的资源配置</li>
<li>一个容器只能分配一个虚拟GPU</li>
</ul>
</li>
<li>NVIDIA Docker
<ul>
<li>使得Docker镜像可以使用GPU</li>
<li>允许GPU驱动对CUDA镜像不感知</li>
<li>提供了一个命令行的封装-&gt;当容器启动时可以挂载driver的用户态组件和GPU设备文件</li>
<li>不能共享：只能把一整个GPU分配给一个容器</li>
</ul>
</li>
<li>ConvGPU
<ul>
<li>容器间共享GPU显存</li>
<li>它拦截了CUDA库来管理每个镜像显存的分配和回收</li>
<li>仅支持分享显存</li>
<li>而且只能虚拟化单个物理GPU</li>
</ul>
</li>
<li><strong>GaiaGPU</strong>
<ul>
<li>软件层虚拟化，没有硬件限制</li>
<li>每个虚拟GPU的资源可以是不一样的</li>
<li>一个容器可以分配多个虚拟GPU</li>
<li>可以同时共享显存和计算资源</li>
<li>可以虚拟化多个物理GPU</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="device-plugin">Device Plugin</h4>
<ul>
<li>致力于征聘各种计算资源（GPUs， NICs， FPGAs）供集群使用</li>
<li>无需改变k8s的核心代码</li>
<li>工作流
<ul>
<li>资源发现
<ul>
<li>实现Device Plugin</li>
<li>通过gRPC将device注册到Kubelet</li>
<li>成功注册后，device plugin发送设备列表</li>
<li>Kubelet负责将这个扩展资源推广给Master</li>
</ul>
</li>
<li>资源分配
<ul>
<li>用户在容器的specification中请求设备</li>
<li>master的scheduler选择一个k8s节点的device plugin发送device请求</li>
<li>device plugin分配对应的设备给容器</li>
</ul>
</li>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828115537.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828115537.png"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></li>
</ul>
</li>
<li><strong>Vaucher</strong>通过利用设备插件框架来实现SGX（Software Guard Extensions）设备虚拟化，
<ul>
<li>该插件框架修改了Kubelet和SGX代码以限制虚拟SGX设备的设备内存的使用</li>
<li>仅处理内存资源</li>
<li>对内存施加严重限制</li>
</ul>
</li>
<li><strong>GaiaGPU</strong>也采用了device plugin框架以在容器之间共享资源
<ul>
<li>对资源采用弹性限制而不是硬限制-&gt;来改善利用率</li>
</ul>
</li>
</ul>
<h3 id="design-and-implementation">Design And Implementation</h3>
<h4 id="设计与实现">设计与实现</h4>
<ul>
<li>目标：在容器间共享显存与计算资源，使用最小的成本获得最大的提升</li>
<li>挑战：
<ul>
<li>透明性：
<ul>
<li>GaiaGPU不应该修改k8s的代码或者容器镜像</li>
<li>使用共享GPU就如同使用物理GPU一样</li>
</ul>
</li>
<li>低开销
<ul>
<li>使用共享GPU的性能尽可能接近使用物理GPU</li>
</ul>
</li>
<li>隔离
<ul>
<li>GaiaGPU应该管理GPU资源在每个容器的分配与回收</li>
<li>共享GPU时容器之间完全隔离</li>
</ul>
</li>
</ul>
</li>
<li>结构：
<ul>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828143547.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828143547.png"
			
			
			
			loading="lazy"
			alt="image-20220828143547571">
	</a>
	
	<figcaption>image-20220828143547571</figcaption>
	
</figure></li>
<li>两层资源管理
<ul>
<li>host层：
<ul>
<li>GPU Manager负责创建vGPUs</li>
<li>GPU Scheduler 负责分配物理GPU资源到vGPUs</li>
</ul>
</li>
<li>容器层
<ul>
<li>vGPU Library负责管理具体容器的GPU资源</li>
</ul>
</li>
</ul>
</li>
<li>组件
<ul>
<li>GPU Manager
<ul>
<li>device plugin：运行在host上负责创建vGPUs，使用gRPC与Kubelet通信</li>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828171002.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828171002.png"
			
			
			
			loading="lazy"
			alt="image-20220828171002587">
	</a>
	
	<figcaption>image-20220828171002587</figcaption>
	
</figure></li>
<li>Register：GPU Manager将自身注册到Kubelet以通知其存在</li>
<li>ListAndWatch：成功注册后，Kubelet调用ListAndWatch获取设备信息List
<ul>
<li>显存：256M 作为一个单元， 每个单元都被称作一个vmemory设备</li>
<li>计算资源：一个GPU被分作100份vprocessor设备， 每个vprocessor都有百分之一的利用率</li>
</ul>
</li>
<li>Allocate：
<ul>
<li>映射过程
<ul>
<li>Kubelet发送随机选择的设备IDs到GPU Manager</li>
<li>GPU Manager根据得到的设备IDs计算所需的物理GPU资源</li>
<li>GPU Manage 发送一个请求到 GPU Scheduler</li>
<li>GPU Scheduler 返回要分配给容器的物理GPU</li>
</ul>
</li>
<li>映射完成后，GPU manager返回一个allocateResponse， 包含获取分配到的设备的Configurations
<ul>
<li>容器的环境变量</li>
<li>挂载到容器的目录和文件</li>
<li>分配的设备</li>
</ul>
</li>
<li>Kubelet将这些配置发送到容器运行时</li>
</ul>
</li>
</ul>
</li>
<li>GPU Scheduler
<ul>
<li>负责处理GPU Manager发来的调度请求</li>
<li>基于拓扑树分配GPU，树的根节点是host， 树的叶节点是物理GPU</li>
<li>当所需要的资源少于一个物理GPU，分配策略会最大程度减少资源碎片</li>
<li>当所需的资源等于一个物理GPU时，采用了最小化单叶节点（即没有兄弟姐妹节点的叶子节点）的分配策略。</li>
<li>当所需的资源不止一个物理GPU时，分配策略的目标是最大程度地降低GPU的通信成本。通信成本取决于两个GPU的连接模式。</li>
</ul>
</li>
<li>vGPU Manager
<ul>
<li>运行在host，传递容器配置并且监管分配了vGPUs的容器</li>
<li>当容器申请GPU资源时，GPU Manager将配置发送给vGPU Manager，例如
<ul>
<li>需要的GPU资源</li>
<li>该容器的name</li>
</ul>
</li>
<li>接收到配置后，在主机上为容器命创建一个唯一的路径
<ul>
<li>路径名为容器名</li>
<li>这个路径包含在allocateResponse里</li>
<li>容器的配置也包含在这个路径里，所以可以通过Kubelet传递到容器</li>
</ul>
</li>
<li>vGPU Manager 和 vGPU Library是 服务器-客户端模式
<ul>
<li>vGPU Manager 维护一个活着的且分配了GPU资源的容器的list</li>
<li>会定期检查这些容器是否存活</li>
<li>如果容器死了，从list中移除这个容器的信息，并且删除目录</li>
</ul>
</li>
</ul>
</li>
<li>vGPU Library
<ul>
<li>运行在容器中，管理容器的GPU资源</li>
<li>在容器第一次执行GPU程序时被加载</li>
<li>启动后vGPU Libraray 向 vGPU Manager注册自身</li>
<li>利用<strong>LD_LIBRARY_PATH</strong>机制拦截CUDA库中内存与计算相关的API
<ul>
<li>LD_LIBRARY_PATH是一个linux系统的环境变量</li>
<li>可以影响程序的runtime link</li>
<li>允许某些路径先于standard set of directories（？标准库目录？）加载</li>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828222019.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828222019.png"
			
			
			
			loading="lazy"
			alt="image-20220828222012346">
	</a>
	
	<figcaption>image-20220828222012346</figcaption>
	
</figure></li>
</ul>
</li>
<li>当容器需要的GPU资源超出它申请的资源时，为了避免耗尽整个GPU，有两种资源限制策略
<ul>
<li><strong>硬限制（hard limiit）</strong>：如果容器资源消耗量超过配额，就不再给该容器分配资源</li>
<li><strong>弹性限制（elastic limit）</strong>：如果容器资源消耗量超过配额，但是系统中还有空闲资源，那么该容器仍然能够得到更多的资源</li>
</ul>
</li>
<li>内存资源的限制采用硬限制策略， 因为
<ul>
<li>内存资源大小能决定一个程序能否运行，但对运行的效率影响较小</li>
<li>GPU是计算设备，它们采用一次性资源分配策略。仅在获取所有内存资源后才可以执行应用程序，并且在完成内存之前不会释放。如果使用弹性内存分配，则具有较大内存需求的应用程序将饿死</li>
<li>撤回过度分配的内存资源的唯一方法是通过抛出out-of-memory exception来杀死该过程</li>
</ul>
</li>
<li>计算资源采用弹性限制策略，因为
<ul>
<li>计算资源对程序运行的影响很大</li>
<li>计算资源（GPU 线程）在执行之后会立刻释放掉</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>总结：
<ul>
<li>Step 1：GPU Manager向Kubelet注册自身，并报告vGPU的信息（ListAndWatch）</li>
<li>Step 2：Kubelet接收到来自Master的创建一个GPU容器的请求</li>
<li>Step 3：Kubelet发送一个allocateRequest到GPU Manager</li>
<li>Step 4：GPU Manager发送一个vGPU调度请求到GPU Scheduler，GPU Scheduler根据调度策略选择实际提供资源的物理GPU。如果调度成功返回一个包含该物理GPU的信息的reponse</li>
<li>Step 5：GPU Manager将容器配置信息发送到vGPU Manager</li>
<li>Step 6：GPU Manager将容器环境变量，挂载信息和设备信息通过allocateResponse返回给Kubelet</li>
<li>Step 7：Kubelet根据allocateResponse创建并且初始化一个容器</li>
<li>Step 8：vGPU Library向vGPU Manager注册自身并且管理其所在容器的GPU资源</li>
<li>Step 9：vGPU Manager持续监控GPU容器状态</li>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828143547.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828143547.png"
			
			
			
			loading="lazy"
			alt="image-20220828143547571">
	</a>
	
	<figcaption>image-20220828143547571</figcaption>
	
</figure></li>
</ul>
</li>
</ul>
<h4 id="优化">优化</h4>
<blockquote>
<ul>
<li>容器的资源不仅会影响应用程序的性能，而且还会确定应用程序的状态</li>
<li>用户在创建容器时无法准确估算所需的资源</li>
<li>因此，我们提供两种方法来更改运行时容器的资源。弹性资源分配会暂时修改容器的计算资源限制，而动态资源分配永久改变了容器的资源。</li>
</ul>
</blockquote>
<ul>
<li>
<p>弹性分配策略</p>
<ul>
<li>目的是使用闲置的计算资源以提高资源利用率</li>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828224059.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828224059.png"
			
			
			
			loading="lazy"
			alt="image-20220828224059056">
	</a>
	
	<figcaption>image-20220828224059056</figcaption>
	
</figure></li>
<li>nanosleep()是Linux内核函数，会挂起当前线程等待一段时间或者直到接收到调用当前线程的信号（Line 2）</li>
<li>为了防止过载， $GU_{max}$ 默认的最大值是90% （Line 3）</li>
<li>如果物理GPU计算卡仍然有空闲资源，也就是说<em>GU free &gt; 0</em>，即使容器的资源请求已经超出其配额，vGPU Library也会继续给容器分配计算资源（Line 4-5）。<strong>如果系统没有剩余的空闲资源（*GU free &lt;= 0*）并且容器的消耗的资源大于其配额，vGPU Library会逐渐收回超额（over-allocated）资源</strong>（Line 6-7）</li>
<li>超额资源的回收采用非抢占式策略（non-preemptive strategy），就是说会等到容器中占用线程的核函数执行完后再回收线程资源。<em><strong>CU cores*可以被理解为一种token，容器执行核函数时需要消耗该token，当核函数执行完成释放线程资源时容器又回重新拥有该token</strong>。<em>CU cores</em>的初始值等于容器的计算资源配额，<em>CU cores</em>为零时（系统没有空闲的资源，并且该容器的计算资源配额都正在被用于执行核函数），vGPU Library不会再给容器分配任何计算资源，直到容器的</em>CU cores<em>大于零（其他容器释放了空闲资源，或者该容器有核函数完成释放了资源，容器重新获得</em>CU cores*）</li>
<li>弹性分配的样例
<ul>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828233026.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220828233026.png"
			
			
			
			loading="lazy"
			alt="image-20220828233026263">
	</a>
	
	<figcaption>image-20220828233026263</figcaption>
	
</figure></li>
<li>首先，容器A申请了0.3个GPU，并且被GPU Scheduler调度到了一个完全空闲的GPU上</li>
<li>由于GPU完全空闲，所以容器A会逐渐占用所有的空闲资源，默认最大可占用90%</li>
<li>此时容器B申请了0.7个GPU，也被调度到了此GPU上，但是由于容器A占用了所有的空闲资源，所以需要从容器A回收超额线程资源并分配给容器B</li>
<li>重复经过几次资源的重新分配，容器A和容器B所占用的资源与其资源配额相同</li>
</ul>
</li>
</ul>
</li>
<li>
<p>动态分配策略</p>
<ul>
<li>动态资源分配会修改容器资源，包括内存和计算资源，而无需停止容器。</li>
<li>动态资源分配旨在解决两个问题
<ul>
<li>在硬限制下更新容器的内存和计算资源</li>
<li>在弹性限制下将内存资源添加到容器中</li>
</ul>
</li>
<li>vGPU Library 通过将容器的资源配置与容器的实际使用进行比较来限制容器资源</li>
<li>要永久更改容器的资源：修改容器的资源配置—&gt;通知GPU Scheduler-&gt;更新相应的物理GPU分配</li>
</ul>
</li>
</ul>
<h3 id="experiments">Experiments</h3>
<p>&hellip;</p>
<h3 id="conclusion">Conclusion</h3>
<p>&hellip;</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p>论文地址 <a href="https://ieeexplore.ieee.org/abstract/document/8672318">https://ieeexplore.ieee.org/abstract/document/8672318</a></p>
</li>
<li>
<p>Github开源代码 <a href="https://github.com/tkestack/gpu-manager">https://github.com/tkestack/gpu-manager</a></p>
</li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/gpu%E8%99%9A%E6%8B%9F%E5%8C%96/">GPU虚拟化</a>
        
            <a href="/tags/k8s/">K8s</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="has-image">
    <a href="/p/polardb-serverless%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A/">
        
        
            <div class="article-image">
                
                    <img src="https://2021.sigmod.org/images/2021sigmod-logo1.jpg" loading="lazy" data-key="" data-hash="https://2021.sigmod.org/images/2021sigmod-logo1.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">PolarDB Serverless论文阅读报告</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (DISQUS) {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2022 Tweakzx
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.5.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#gaiagpusharing-gpus-in-container-clouds论文笔记">《GaiaGPU：Sharing GPUs in Container Clouds》论文笔记</a>
      <ol>
        <li><a href="#abstract">Abstract</a></li>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#related-work">Related Work</a>
          <ol>
            <li><a href="#gpu虚拟化">GPU虚拟化</a></li>
            <li><a href="#device-plugin">Device Plugin</a></li>
          </ol>
        </li>
        <li><a href="#design-and-implementation">Design And Implementation</a>
          <ol>
            <li><a href="#设计与实现">设计与实现</a></li>
            <li><a href="#优化">优化</a></li>
          </ol>
        </li>
        <li><a href="#experiments">Experiments</a></li>
        <li><a href="#conclusion">Conclusion</a></li>
      </ol>
    </li>
    <li><a href="#参考资料">参考资料</a></li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
