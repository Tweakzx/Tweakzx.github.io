<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='Gandiva 论文阅读笔记 Abstract Gandiva: 一个集群调度框架，使用特定领域知识，优化了GPU集群训练深度学习模型的延迟与效率 深度学习job的特征 1）反馈驱动的探索： 一'><title>【论文笔记】Gandiva论文阅读笔记</title>

<link rel='canonical' href='https://tweakzx.github.io/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0gandiva%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='【论文笔记】Gandiva论文阅读笔记'>
<meta property='og:description' content='Gandiva 论文阅读笔记 Abstract Gandiva: 一个集群调度框架，使用特定领域知识，优化了GPU集群训练深度学习模型的延迟与效率 深度学习job的特征 1）反馈驱动的探索： 一'>
<meta property='og:url' content='https://tweakzx.github.io/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0gandiva%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/'>
<meta property='og:site_name' content='Tweakzx'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='Gandiva' /><meta property='article:tag' content='论文' /><meta property='article:published_time' content='2022-11-08T09:59:52&#43;08:00'/><meta property='article:modified_time' content='2022-11-08T09:59:52&#43;08:00'/><meta property='og:image' content='https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211081933118.png' />
<meta name="twitter:title" content="【论文笔记】Gandiva论文阅读笔记">
<meta name="twitter:description" content="Gandiva 论文阅读笔记 Abstract Gandiva: 一个集群调度框架，使用特定领域知识，优化了GPU集群训练深度学习模型的延迟与效率 深度学习job的特征 1）反馈驱动的探索： 一"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211081933118.png' />
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0gandiva%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">
                
                    <img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211081933118.png" loading="lazy" alt="Featured image of post 【论文笔记】Gandiva论文阅读笔记" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E8%AE%BA%E6%96%87/" >
                论文
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0gandiva%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">【论文笔记】Gandiva论文阅读笔记</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Nov 08, 2022</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    21 minute read
                </time>
            </div>
        
    </footer>
    
</div>

    

</header>

    <section class="article-content">
    <h1 id="gandiva-论文阅读笔记">Gandiva 论文阅读笔记</h1>
<h2 id="abstract">Abstract</h2>
<ul>
<li>
<p>Gandiva: 一个集群调度框架，使用特定领域知识，优化了GPU集群训练深度学习模型的延迟与效率</p>
</li>
<li>
<p>深度学习job的特征</p>
<ul>
<li>1）反馈驱动的探索：
<ul>
<li>一个用户经常运行一组作业(或 a multi-job)来获得特定任务的最佳结果</li>
<li>并使用关于准确性的早期反馈来动态优先考虑或杀死一个作业子集</li>
<li>同步发生的多个作业的早期反馈是至关重要的</li>
</ul>
</li>
<li>2）深度学习工作在资源使用方面的<strong>异构</strong>，这使得它很难实现最适合的先验。</li>
<li>3）作业内可预测性：因为作业会重复执行叫做mini-batch的迭代
<ul>
<li>Gandiva利用这个特征解决了1）2）两个问题</li>
<li>利用可预测性对GPU进行多个job间进行时分复用， 这提供了低延迟</li>
<li>这种预测性还可以用于内省job性能并动态迁移到最合适的GPU上，提高了集群效率</li>
</ul>
</li>
</ul>
</li>
<li>
<p>我们通过一个原型实现和微基准测试表明</p>
<ul>
<li>Gandiva 可以在深度学习过程<strong>加快超参数搜索</strong>一个数量级</li>
<li>并通过<strong>透明迁移</strong>和<strong>job时分</strong>实现更好的利用，使job与资源的更好地匹配。</li>
<li>在一个运行在180-GPU 集群中的实际工作负载中，Gandiva 将集群的总利用率提高了26%</li>
<li>这为深度学习提供了一种管理大型 GPU 集群的新方法。</li>
</ul>
</li>
</ul>
<h2 id="introduction">Introduction</h2>
<ul>
<li>
<p>DLT  job的特征</p>
<ul>
<li>
<p>反馈驱动</p>
<ul>
<li>
<p>超参数搜索：</p>
<ul>
<li>用户通常会尝试一个作业的几个配置（a multi-job），并利用这些作业的早期反馈来决定是否优先处理或杀死其中的一些子集。</li>
</ul>
</li>
</ul>
<blockquote>
<p>传统的调度器运行一个工作子集， 完成前其他工作排队</p>
<ul>
<li>这种模式不适合multi-jobs，因为a multi-job中的所有工作需要<strong>同时</strong>得到早期反馈。</li>
<li>另外，伴随着multi-jobs，其他已经确定了正确的超参数的DLT作业，运行了几个小时到几天，导致了行头阻塞，因为长期运行的作业对GPU拥有独家访问权，直到完成，而取决于早期反馈的多作业则在队列中等待。</li>
<li>长的排队时间迫使用户要么使用预留的GPU，要么要求集群超额配置，从而降低集群效率。</li>
</ul>
</blockquote>
</li>
<li>
<p>异构</p>
<ul>
<li>Jobs之间的固有差异
<ul>
<li>显存使用</li>
<li>核使用</li>
<li>带宽敏感性</li>
<li>job之间的干扰</li>
</ul>
</li>
</ul>
<blockquote>
<p>传统调度器将job视作黑箱，无法取得最优的集群效率</p>
</blockquote>
</li>
<li>
<p>作业内可预测</p>
</li>
</ul>
</li>
<li>
<p>Gandiva</p>
<ul>
<li>Gandiva利用可预测性来执行剖析驱动的自省。
<ul>
<li>它使用小批量的进度率来不断反省其决策，以提高集群效率。</li>
<li>例如，只有在内存和GPU利用率较低时，它才会将多个作业装箱在同一个GPU上</li>
<li>它动态地将通信密集型作业迁移到更多的亲和力强的GPU上</li>
<li>它还会适时地 &ldquo;增长 &ldquo;作业的并行程度，以利用空闲资源，并在空闲资源消失后缩小作业。</li>
<li>我们目前实施的自省策略是一个有状态的试错策略，它是可行的，因为它的预测能力很强。</li>
</ul>
</li>
<li>Gandiva除了特定的内省核调度策略，还提供了一些API</li>
<li>API：（a）高效的挂起恢复或时间切片，（b）低延迟迁移，（c）细粒度监控，（d）弹性，以及（e）动态优先级。
<ul>
<li>这些原语高效的关键是Gandiva的协同设计：跨越调度器层与DLT工具包层（如pytorch， tensorflow)</li>
</ul>
</li>
<li>通过利用GPU集群的专用性，Gandiva为深度学习的特定工作负载定制了调度器，从而为调度器提供了对工作的更多可见性和控制，同时仍然实现了对任意DLT工作的通用性。</li>
<li>Gandiva的实现
<ul>
<li>修改两个流行的框架 PyTorch 和 Tensorflow ，为调度程序提供必要的新原语</li>
<li>并在 Kubernetes 和 Docker 容器之上实现了一个初始调度策略管理器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>本文贡献</p>
<ul>
<li>我们说明了深度学习工作流程的各种独特特征，并将其映射到集群调度所需的具体要求。</li>
<li>我们确定了DLT作业调度策略可以使用的通用原语，并提供了应用感知技术，通过利用DL特有的作业内周期性知识，使时间切割和迁移等原语的效率提高了一个数量级，从而变得实用。</li>
<li>我们提出并评估了一个新的自省式调度框架，该框架利用DLT工作的特定领域知识来不断完善其调度决策，从而显著改善早期反馈时间并提供高集群效率。</li>
</ul>
</li>
</ul>
<h2 id="backgroud">Backgroud</h2>
<ul>
<li>
<p>反馈驱动的探索。</p>
<ul>
<li>实现高精确度的一个前提条件是模型的选择。新模型的发现，如ResNet或Inception，如今大多是一个试错的过程，尽管使之自动化的方法是一个活跃的研究领域。</li>
<li>除了模型结构外，还有一些参数，称为超参数，也需要作为DLT工作的一部分被指定。超参数包括模型中的层数/权重、最小批量大小、学习率等。这些参数通常由用户根据领域知识和试错来选择，有时甚至会导致早期训练失败。</li>
<li>因此，DLT工作的早期反馈是至关重要的，特别是在训练的初始阶段。</li>
</ul>
</li>
<li>
<p>multi-job</p>
<ul>
<li>
<p>一旦用户确定了要进一步探索的特定模型，用户通常会进行超参数搜索以提高任务的准确性。</p>
</li>
<li>
<p>这可以在超参数空间上使用各种搜索技术来完成；也就是说，用户生成多个DLT任务或多任务，每个任务使用<strong>一组超参数或配置</strong>进行全面训练。由于用户通常会探索数百个这样的配置，这个过程在计算上是很昂贵的。</p>
</li>
<li>
<p>因此，文献中出现了复杂版本的超参数搜索，如HyperOpt和Hyperband。</p>
<blockquote>
<p>例如，Hyperband最初可能会产生128个DLT作业，并在每一轮（例如100个小批量迭代）中，杀死一半精度最低的作业。</p>
</blockquote>
</li>
<li>
<p>同样，对于这些算法来说，对整个作业集的早期反馈是至关重要的，因为否则他们将无法做出有效的训练决定。</p>
</li>
</ul>
</li>
</ul>
<h2 id="dlt-job的特征">DLT job的特征</h2>
<h3 id="对位置locality敏感">对位置（locality)敏感</h3>
<ul>
<li>多GPU DLT工作的性能取决于分配的GPU的亲和力。
<ul>
<li>不同的DLT工作对GPU间的亲和力表现出不同程度的敏感性。</li>
<li>即使是同一台机器上的GPU，由于不对称的架构，我们观察到不同程度的GPU之间的亲和力
<ul>
<li>两个GPU可能位于不同的CPU插槽（表示为DiffSocket）</li>
<li>在同一个CPU插槽，但在不同的PCIe Switch（表示为SameSocket）</li>
<li>在同一个PCIe Switch（表示为SamePCIeSw）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211081932589.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211081932589.png"
			
			
			
			loading="lazy"
			alt="image-20221108193230029">
	</a>
	
	<figcaption>image-20221108193230029</figcaption>
	
</figure></p>
<ul>
<li>图1显示了两个模型VGG16[44]和ResNet-50[24]对服务器内定位的不同敏感性。
<ul>
<li>当使用Tensorflow的两个P100 GPU进行训练时，VGG16在不良定位下受到很大影响。</li>
<li>在最差的定位下，当两个GPU位于不同的CPU插座上时，VGG16只实现了最佳定位配置的60%，即两个GPU被放置在同一个PCIe开关下。</li>
<li>另一方面，在这种设置下，ResNet-50不受GPU定位的影响。这是因为VGG16是一个比ResNet-50更大的神经模型，因此在每个小批次中的模型同步会在底层PCIe总线上产生更高的通信负荷。</li>
</ul>
</li>
<li>我们在分布式环境中观察到类似的趋势。图2显示了一个4GPU Tensorflow作业的性能，它以不同的服务器间定位运行，训练ResNet-50和InceptionV3[46]模型。
<ul>
<li>即使是用40G InfiniBand网络互连，当作业被分配到4个GPU时，性能差异明显，
<ul>
<li>其中它们均匀地分散在4台服务器（表示为4*1-GPU）</li>
<li>2台服务器（表示为2*2-GPU）</li>
<li>以及全部在一台服务器（表示为本地4GPU）</li>
<li>尽管两个模型对位置性的敏感性不同。</li>
</ul>
</li>
</ul>
</li>
<li>因此，DLT调度器在分配GPU时必须考虑到作业对位置的敏感性。</li>
</ul>
<h3 id="对干扰敏感">对干扰敏感</h3>
<ul>
<li>当在一个共享的执行环境中运行时，DLT工作可能会因为资源争夺而相互干扰。我们再次观察到，不同的DLT工作表现出不同程度的干扰。</li>
</ul>
<p><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211081932419.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211081932419.png"
			
			
			
			loading="lazy"
			alt="image-20221108193107517">
	</a>
	
	<figcaption>image-20221108193107517</figcaption>
	
</figure></p>
<ul>
<li>
<p>即使对于单GPU作业，也存在干扰。</p>
<ul>
<li>图3显示了: 当把一个语言模型作业（标记为LM）与另一个作业放在同一个PCI-e交换机下时，由于服务器内的干扰而导致的性能下降情况。
<ul>
<li>当两个LM一起运行时，两个作业都会遭受19%的减速。</li>
<li>然而，ResNet-50并没有受到GPU与LM共处的影响。</li>
<li>神经机器翻译（GNMT）[51]对LM的干扰程度不大。</li>
<li>同样地，我们也观察到不同类型的训练模型对多GPU训练的不同程度的干扰。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>图4显示了用40G InfiniBand网络连接的两个4GPU服务器上的服务器间干扰。</p>
<ul>
<li>当运行多个2-GPU作业时，每个GPU被放在不同的服务器上，
<ul>
<li>ResNet-50显示出高达47%的减速，</li>
<li>InceptionV3显示出30%的减速，</li>
<li>而DeepSpeech[23]仅显示出5%的减速。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>总之，不同应用领域的流行深度学习模型，如视觉、语言和语音，表现出对位置性和干扰的不同程度的敏感性。为了迎合这些挑战，Gandiva利用了DLT工作的一个关键特征，我们接下来会详细说明。</p>
</li>
</ul>
<h3 id="job内可预测性">job内可预测性</h3>
<p><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211081933633.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211081933633.png"
			
			
			
			loading="lazy"
			alt="image-20221108193308480">
	</a>
	
	<figcaption>image-20221108193308480</figcaption>
	
</figure></p>
<ul>
<li>一个DLT作业包括许多小批量的迭代， 呈现对应的周期性。
<ul>
<li>图5(a)显示了在四个K80 GPU上使用ResNet-50模型对ImageNet数据进行训练的20s快照期间使用的GPU总内存。
<ul>
<li>所使用的GPU内存明显遵循一个周期性模式。</li>
<li>每个周期都对应着一个小批次的处理（大约1.5s），内存在前向传递中增加，在后向传递中减少。</li>
<li>使用的最大和最小的GPU内存分别为23GB和0.3GB，或77倍的系数。</li>
<li>这个比例随着迷你批处理量的增加而扩大（通常在16到256之间；本例中为128）。</li>
</ul>
</li>
<li>图5(b)显示了在一个K80 GPU上使用GNMT模型时，对WMT'14英语德语数据集进行训练的20s快照所使用的GPU总内存。
<ul>
<li>虽然小批量迭代与ImageNet的例子不完全相同（由于不同的句子长度和PyTorch中使用的动态图），但该图具有类似的循环性质。</li>
<li>最大值和最小值之间的差异较小（3倍），主要是由于较大的模型（0.4GB）和较小的迷你批次大小（本例中为16）。</li>
</ul>
</li>
<li>除了这里显示的图像和语言模型外，其他训练领域，如语音、生成式逆向网络（GAN）和变异自动编码器都遵循类似的循环模式（由于空间限制没有显示），因为训练的核心是梯度下降算法，执行许多小批量迭代。</li>
</ul>
</li>
<li>充分利用可预测性。
<ul>
<li>首先，一个DLT作业可以被自动分割成小批量的迭代，这些迭代在60秒内的集合，例如一个微任务，形成一个调度间隔。</li>
<li>第二，通过在内存周期的最小值上执行暂停操作，可以大大减少从GPU复制到CPU中的内存量，从而使暂停/恢复和迁移的效率比naive的实现要高一个数量级。</li>
<li>第三，可以对小批量的进度进行分析，并将其作为评估装箱或迁移等机制的有效性的代理。</li>
</ul>
</li>
</ul>
<h2 id="设计">设计</h2>
<p><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211081934805.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211081934805.png"
			
			
			
			loading="lazy"
			alt="image-20221108193438681">
	</a>
	
	<figcaption>image-20221108193438681</figcaption>
	
</figure></p>
<ul>
<li>如今的集群中出现高延迟和低利用率的问题
<ul>
<li>是因为DLT作业被专门分配了一组<strong>固定</strong>的GPU。</li>
<li><strong>独占</strong>访问 GPU 的原因行头阻塞，阻塞了早期反馈，导致作业的排队时间过长。</li>
<li>当作业无法完全利用其分配的GPU时，对一组固定的GPU的独家访问也会导致GPU的低利用率。</li>
</ul>
</li>
</ul>
<h3 id="机制">机制</h3>
<ul>
<li>三种方式消除GPU对DLT作业的排他性和固定分配来解决低效率问题
<ul>
<li>首先，在过载期间，Gandiva允许后来的工作与现有的工作<strong>共享</strong>GPU
<ul>
<li>而不是等待当前工作的离开。</li>
<li>这是为DLT作业定制的<strong>挂起-重启机制</strong>和<strong>选择性装箱</strong>而实现的。</li>
</ul>
</li>
<li>第二，Gandiva支持DLT作业从一组GPU到另一组的<strong>高效迁移</strong>
<ul>
<li>迁移允许时间碎片化的作业迁移到其他（最近空出的）GPU上</li>
<li>或者对集群进行去碎片化处理，从而使后来的作业被分配到具有良好位置性的GPU上。</li>
</ul>
</li>
<li>第三，Gandiva支持GPU增长-缩减机制
<ul>
<li>这样空闲的GPU就可以适时地被使用。</li>
<li>为了有效地支持这些机制并实现有效的资源管理，Gandiva通过不断地<strong>剖析</strong>DLT作业的资源使用情况并估计其性能，对DLT作业进行内省。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="挂起-重启与装箱">挂起-重启与装箱</h4>
<ul>
<li>
<p>Suspend-resume</p>
<ul>
<li>挂起-重启是Gandiva用来消除一组GPU对DLT作业的独占性的一种机制。
<ul>
<li>Gandiva利用这种机制，增加了对GPU时间分割的自定义支持。</li>
</ul>
</li>
<li>Gandiva的关键思想是利用这种周期性行为，在DLT作业的<strong>GPU显存使用量最低</strong>时暂停-恢复。
<ul>
<li>1）发出暂停调用</li>
<li>2）DLT工具包会等到内存使用周期的最小值，将存储在GPU中的对象复制到CPU，释放其所有GPU内存分配（包括缓存）</li>
<li>3）然后调用经典的CPU暂停机制</li>
<li>4）之后，当CPU恢复工作时，DLT框架首先分配适当的GPU内存，将存储的对象复制回GPU，然后恢复工作。</li>
</ul>
</li>
<li>Suspend-resume也可以在同一台服务器中启动GPU的更换
<ul>
<li>虽然更换GPU的成本很高，但我们可以把这个延迟从关键路径中隐藏
<ul>
<li>典型的图像分类工作，暂停-恢复一起可以在100ms内完成</li>
<li>而对于大型语言翻译工作，暂停-恢复可能需要1s</li>
</ul>
</li>
<li>考虑到1分钟的时间切分间隔，这相当于2%或更少的开销</li>
</ul>
</li>
<li>延迟
<ul>
<li>Gandiva中的suspend可能最多<strong>延迟</strong>DLT作业的一个小批次间隔</li>
<li>值得
<ul>
<li>由于减少了GPU-CPU的复制成本和更少的CPU使用的内存，它的开销明显减少</li>
<li>在这个延迟期间还完成了有用的工作。</li>
</ul>
</li>
<li>调度器跟踪这一延迟，并相应地调整时间分割的间隔，以实现公平性</li>
</ul>
</li>
</ul>
</li>
<li>
<p>装箱</p>
<ul>
<li>暂停-恢复的另一种方法是装箱
<ul>
<li>在一个GPU上同时运行多个DLT作业，让GPU分担作业的时间。</li>
</ul>
</li>
<li>有效性
<ul>
<li>只有当装箱的作业不超过GPU的资源，并且不会对彼此产生不利影响时，GPU中的装箱才是有效的。</li>
<li>如果作业相互干扰，装箱就会比暂停-恢复差很多。</li>
</ul>
</li>
<li>装箱的使用
<ul>
<li>当DLT作业有排他性的访问时，我们使用Profiling来监测它们的资源和进度</li>
<li>如果两个作业被确定为装箱的候选者，我们就把它们装箱在一起，并继续监控它们</li>
<li>如果给定的装箱结果对作业的性能产生了不利影响，我们就解除这些作业的装箱并恢复到暂停-恢复状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="迁移">迁移</h4>
<ul>
<li>迁移是Gandiva用来改变分配给DLT作业的GPU集的机制。
<ul>
<li>迁移在几种情况下是有用的
<ul>
<li>i）将时间分割的作业移到集群中任何地方的空闲GPU上</li>
<li>ii）将相互干扰的作业移开</li>
<li>iii）对集群进行去碎片化处理，使进入的作业获得具有良好位置性的GPU</li>
</ul>
</li>
<li>我们评估了两种解决DLT进程状态迁移的方法。
<ul>
<li>在第一种方法中，我们利用一个通用的进程迁移机制，如<strong>CRIU</strong>。
<ul>
<li>CRIU本身不支持使用GPU设备的进程迁移
<ul>
<li>我们首先对GPU对象进行检查</li>
<li>调用CRIU之前从进程中删除所有GPU状态</li>
</ul>
</li>
<li>因为CRIU检查点和恢复整个进程的内存
<ul>
<li>对于这些使用PyTorch的DLT作业来说，检查点的大小是GB级别的。</li>
<li>对于单GPU作业来说，所产生的迁移开销约为810s，对于多GPU作业来说则更高。</li>
</ul>
</li>
</ul>
</li>
<li>我们考虑的第二种方法是使用具有检查点意识的DLT作业。
<ul>
<li>Tensorflow等DLT框架已经支持允许自动检查点和恢复模型的API</li>
<li>通过在迁移前对目的地进行<strong>预热</strong>，并且只迁移必要的训练状态。我们可以降低迁移开销小到一两秒</li>
</ul>
</li>
</ul>
</li>
<li>无论采用哪种方法，我们发现，与它在提高GPU总体利用率方面提供的好处相比，服务器间迁移的开销是值得的</li>
</ul>
</li>
</ul>
<h4 id="增长与收缩">增长与收缩</h4>
<ul>
<li>Gandiva用来消除GPU对DLT作业的排他性的第三个机制是增长-收缩。
<ul>
<li>这种机制主要针对集群可能没有被完全利用的情况</li>
<li>基本思想
<ul>
<li>在空闲时间内，适时地增加可用于作业的GPU数量</li>
<li>在负载增加时相应地减少可用的GPU数量</li>
</ul>
</li>
<li>许多DLT工作，特别是在图像领域，随着GPU数量的增加，会看到线性的性能扩展。
<ul>
<li>Gandiva只对那些特别声明他们有足够的适应性来利用这些增长机会的DLT工作应用这一机制。</li>
<li>当多个DLT工作符合这一标准时，Gandiva使用Profiling来估计每个工作的进度，然后相应地分配GPU。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="profiling">Profiling</h4>
<ul>
<li>Gandiva监控资源使用情况
<ul>
<li>如CPU和GPU利用率，CPU/GPU内存等。</li>
<li>Gandiva的独特之处在于，它还以一种应用感知的方式内省
<ul>
<li>利用了DLT作业表现出的规律内省</li>
<li>利用周期性以估计DLT进度</li>
</ul>
</li>
<li>Gandiva估计DLT作业的mini_batch时间
<ul>
<li>即对一批输入数据做一次前向/后向传递的时间，作为GPU内存使用周期的两个最小值之间的时间</li>
<li>由于DLT作业在其生命周期中通常会执行数百万次这样的小批量操作，调度器会在调度决策之前和之后比较DLT的mini_batch时间以确定其有效性。</li>
</ul>
</li>
<li>Gandiva可以决定装箱是否有效
<ul>
<li>通过比较装箱前后两个DLT作业的小批量时间</li>
<li>如果没有这样的剖析，为了做出装箱的决定
<ul>
<li>人们不仅要对两个DLT作业在不同GPU上的性能进行建模，</li>
<li>还要对它们可能相互干扰的各种方式进行建模（例如，缓存、内存带宽等）</li>
<li>这不是一项简单的任务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="调度原则">调度原则</h3>
<ul>
<li>
<p>定义：在我们描述调度器的细节之前，我们定义一些术语。</p>
<ul>
<li>DLT作业
<ul>
<li>被封装在容器中, 包括
<ul>
<li>所需的GPU数量</li>
<li>优先级（可以是动态的 ）</li>
<li>一个指示作业是否能够增长-收缩的标志</li>
</ul>
</li>
<li>我们假设一个作业所要求的GPU数量是2的幂。</li>
</ul>
</li>
<li>集群
<ul>
<li>一个集群由一个或多个服务器组成</li>
<li>每个服务器有一个或多个GPU</li>
<li>我们假设一个专门的GPU集群用于DLT工作</li>
</ul>
</li>
<li>服务器的高度
<ul>
<li>定义为⌈M/N]， 其中M是分配的GPU数量，N是总GPU的数量。</li>
<li>只有当服务器的高度超过1时，才会使用暂停/恢复机制。</li>
</ul>
</li>
<li>集群的高度
<ul>
<li>被定义为其所有服务器的最大高度。</li>
<li>当集群的高度大于1时，就会出现过载；即所有作业的请求/分配的GPU之和大于GPU的总数。</li>
</ul>
</li>
<li>服务器的亲和力
<ul>
<li>被定义为分配给该服务器的作业类型。</li>
<li>例如，最初服务器的亲和力为零，如果一个需要两个GPU的作业被分配到一个服务器上，那么该服务器的亲和力就会变成两个。</li>
<li>这个参数被调度器用来将具有类似GPU需求的作业分配到同一台服务器上。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>目标</p>
<ul>
<li>Gandiva调度器的主要设计目标是<strong>为作业提供早期反馈</strong>。
<ul>
<li>在流行的调度器中，作业在过载期间会在队列中等待。</li>
<li>Gandiva通过立即为新作业分配GPU并使用suspend-resume机制提供早期结果来支持超额订阅。</li>
</ul>
</li>
<li>第二个设计目标是<strong>集群效率</strong>。
<ul>
<li>通过一个持续的优化过程来实现，该过程使用了剖析和贪婪的启发式，利用了诸如装箱、迁移和增长-收缩等机制。</li>
</ul>
</li>
<li>集群级的公平性<strong>不是</strong>Gandiva的设计目标。
<ul>
<li>只关注使用暂停-恢复机制在每个服务器上提供作业之间的公平性</li>
<li>集群级的公平性留给未来工作</li>
</ul>
</li>
<li>为了实现这些目标，Gandiva调度器以两种模式运行：
<ul>
<li>响应模式：调度器对诸如工作到达、离开、机器故障等事件做出反应</li>
<li>内省模式： 一个持续的过程，过程中，调度器的目标是提高集群的利用率和作业完成时间</li>
<li>请注意，调度器可以同时在两种模式下运行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="响应模式">响应模式</h4>
<p>响应模式被设计用来处理诸如工作到达、离开和机器故障的事件</p>
<p><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211082206024.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211082206024.png"
			
			
			
			loading="lazy"
			alt="image-20221108220646915">
	</a>
	
	<figcaption>image-20221108220646915</figcaption>
	
</figure></p>
<p>当一个新的作业到达时，调度器为该作业分配服务器/GPU。</p>
<ul>
<li>
<p>Gandiva使用的节点分配策略如算法1所示。</p>
<ul>
<li>findNodes是一个函数，用于返回满足作业请求的节点候选者，并有一个亲和力约束的可选参数。</li>
<li>最初，Gandiva试图找到与新工作具有相同亲和力的节点，并在这些节点中找到具有最小负载的节点。如果存在这样的节点，并且它们的高度小于1（第5-6行），该节点将被分配。</li>
<li>否则，Gandiva试图找到并分配未亲和的节点（第7-8行）。</li>
<li>如果没有这样的空闲服务器，第三个选择是寻找有空闲GPU的节点，同时忽略亲和力（第9-10行）。</li>
<li>这可能会导致多个节点之间的碎片化分配，但正如我们将在后面看到的，迁移可以用于碎片化。如果上述方法都不奏效，这意味着集群中没有可用的GPU。在这种情况下，如果存在具有相同亲和力的节点，它们将被用于暂停-恢复（第11-12行）；</li>
<li>如果没有，作业将被排队（第13-14行）。</li>
</ul>
</li>
<li>
<p>放置job</p>
<ul>
<li>
<blockquote>
<p>传统的调度器将使用<strong>作业离开</strong>来触发从等待队列中挑选下一个作业。</p>
</blockquote>
</li>
<li>
<p>Gandiva检查集群的高度是否可以减少</p>
<ul>
<li>将被暂停的作业迁移到新的空闲GPU上</li>
<li>这个作业可能来自同一台服务器或集群中的任何其他服务器。</li>
<li>作业的离开也可以触发迁移，以改善位置性</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Gandiva的工作安排Policy时考虑到了两个因素。</p>
<ul>
<li>Gandiva<strong>允许超额认购</strong>。
<ul>
<li>当一个服务器被超额认购时，我们会进行<strong>加权轮流调度</strong>，给每个作业公平的时间份额。</li>
</ul>
</li>
<li>GPU分配不是作业到达时的一次性事件，Gandiva使用自省模式来<strong>持续改善</strong>集群的利用率。
<ul>
<li>因此，Gandiva依靠一个简单的作业安置策略来快速分配GPU资源给新作业，从而实现早期反馈。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="内省模式">内省模式</h4>
<p>在自省模式下，Gandiva持续监控并优化作业在集群中的GPU上的位置，以提高DLT作业的整体利用率和完成时间。</p>
<ul>
<li>
<p>装箱</p>
<ul>
<li>只有在过载时才会考虑装箱。
<ul>
<li>基本思想：在GPU上同时运行两个或多个作业以提高效率。</li>
<li>可能无效
<ul>
<li>如果装箱工作的内存需求加起来高于GPU的内存，那么从CPU内存中 &ldquo;分页 &ldquo;的开销就会很高，装箱就没有效果。</li>
<li>当两个或更多作业的内存需求小于GPU内存时，装箱仍然可能不比暂停-恢复更有效。</li>
</ul>
</li>
</ul>
</li>
<li>鉴于DLT作业的异质性，对装箱的性能进行分析建模是一个具有挑战性的问题。
<ul>
<li>相反，Gandiva依靠一种贪婪的启发式方法来装箱job。
<ul>
<li>当job到达时，我们总是使用暂停-恢复的独占模式运行它们，并收集剖析信息（GPU利用率、内存和作业进展率）。</li>
<li>基于剖析数据，调度器维护一个按GPU利用率排序的作业列表。</li>
<li>调度器贪婪地挑选出GPU利用率最低的作业，并试图将其装箱到具有最低GPU利用率的GPU上。我们只在装箱作业的总内存利用率不超过GPU的总内存时才这样做。</li>
<li>当装箱作业的总吞吐量大于时间切割时，装箱被认为是成功的。</li>
<li>如果装箱不成功，我们就撤消装箱，并尝试下一个利用率最低的GPU。</li>
<li>如果装箱成功，我们找到下一个利用率较低的作业并重复这个过程。</li>
</ul>
</li>
<li>根据我们的评估，我们发现这个简单的贪婪的启发式方法实现了26%的效率提升。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>迁移</p>
<ul>
<li>GPU的位置性在一些作业的性能中起着重要作用。</li>
<li>在Gandiva中
<ul>
<li>每当作业离开时，我们都会使用迁移来改善位置性，</li>
<li>同时也作为一个后台进程来 &ldquo;整理 &ldquo;集群的内容。</li>
<li>为了改善位置性，我们挑选那些不在同一地点的作业，并试图找到一个新的同一地点的位置。</li>
</ul>
</li>
</ul>
<blockquote>
<p><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211091112968.png" >
		<img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211091112968.png"
			
			
			
			loading="lazy"
			alt="image-20221109111201868">
	</a>
	
	<figcaption>image-20221109111201868</figcaption>
	
</figure></p>
<ul>
<li>图8展示了一个集群实验的例子（第6.4节）。
<ul>
<li>当一个有4个作业、每个作业需要2个GPU的多作业被安排时，它的GPU亲和性很差；
<ul>
<li>只有J0的两个GPU被安排在一起，而多作业中的其他3个作业（J1、J2和J3）被分配到不同的GPU。</li>
<li>三分钟后，一个背景训练作业DeepSpeech完成了，并释放了它的8个GPU。</li>
<li>8个GPU中的3个，在图8中标记为D，位于三个不同的服务器（服务器1、3和4），可以提高多任务的训练效率。</li>
<li>因此，Gandiva启动了迁移过程，将J1、J2和J3重新安置到同地的GPU。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>去碎片化
<ul>
<li>我们在所有非空闲的服务器中挑选出拥有最多空闲GPU的服务器。</li>
<li>然后我们尝试将运行在该服务器上的作业迁移到其他服务器上。</li>
<li>只要性能损失可以忽略不计，作业就会被迁移到另一个空闲GPU较少的服务器上。</li>
<li>我们重复这个过程，直到每台非空闲服务器上的空闲GPU数量少于阈值（在我们的实验中是4个中的3个），或者没有作业会从迁移中受益。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>扩缩</p>
<ul>
<li>增长-收缩的条件
<ul>
<li>集群未被充分利用</li>
<li>DLT作业明确指出自己可以进行增长-收缩</li>
</ul>
</li>
<li>限制
<ul>
<li>在我们目前的系统中，我们只让作业增长到<strong>单台服务器</strong>中可用的最大GPU数量。</li>
<li>此外，我们只在<strong>空闲一段时间后</strong>触发增长，以避免惊扰，</li>
<li>在新作业可能需要GPU时<strong>立即收缩</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时分</p>
<ul>
<li>我们在每个服务器中支持轮回调度，以公平地分享GPU。</li>
<li>当作业有多个优先级时，较高优先级的作业将不会被暂停以适应较低优先级的作业。</li>
<li>如果一台服务器被较高优先级的作业完全利用，如果可行的话，较低优先级的作业将被迁移到另一台服务器。</li>
</ul>
</li>
</ul>
<h2 id="实现">实现</h2>
<p>DLT作业被封装为Docker容器，其中包含我们定制的DL工具箱和Gandiva客户端的版本。这些工作被提交给Kubernetes系统。Gandiva还实现了一个定制的调度器，然后对这些作业进行调度。</p>
<h3 id="调度器">调度器</h3>
<ul>
<li>
<p>Gandiva由一个定制的中央调度器和一个客户端组件组成，客户端是每个DLT工作容器的一部分。</p>
</li>
<li>
<p>调度器只是另一个由Kubernetes管理的容器。</p>
<ul>
<li>Kubernetes负责整体集群管理，</li>
<li>Gandiva调度器管理DLT作业的调度。</li>
<li>Gandiva调度器使用Kubernetes API来获取集群节点和容器信息，每当提交一个新的容器时，调度器会根据调度策略将其分配给集群中的一个或多个GPU。</li>
</ul>
</li>
<li>
<p>当一个容器被安排在一个节点上时</p>
<ul>
<li>最初只有Gandiva客户端开始执行。</li>
<li>然后，它轮询Gandiva调度器，以确定哪些GPU可用于DLT工作，</li>
<li>并使用暂停/恢复和迁移命令控制DLT工作的执行。</li>
</ul>
</li>
<li>
<p>虽然我们集群中所有GPU的调度完全由中央调度器控制，但如果弹性成为我们关心的问题，可能需要一个分层的方法。</p>
</li>
</ul>
<h3 id="dl工具的修改">DL工具的修改</h3>
<ul>
<li>
<p>PyTorch的时分。</p>
<ul>
<li>
<p>发出SIGTSTP信信号</p>
<ul>
<li>Gandiva client会发出一个SIGTSTP信号，表示工具包必须暂停进程。</li>
<li>它还指示恢复是否应该通过内存文件在新的GPU中发生。</li>
<li>收到信号后，工具包会设置一个暂停标志，并且只在一个小批处理边界的末端执行暂停。</li>
</ul>
</li>
<li>
<p>识别mini-batch边界</p>
<ul>
<li>在Tensorflow这个定义并运行的工具包中，mini-batch的边界很容易识别（session.run()的结束）。</li>
<li>在PyTorch这个逐一定义的工具包中，
<ul>
<li>我们通过跟踪GPU内存使用周期来确定mini-batch的边界，</li>
<li>这是PyTorch的GPU内存管理器（THCCachingAllocator）的一部分，</li>
<li>每当GPU内存被释放时，我们就会寻找一个<strong>周期最小值</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>执行暂停</p>
<ul>
<li>一旦检测到周期最小值，工具包 i）将所有存储的对象从GPU复制到CPU，ii）释放GPU分配，以及iii）暂停进程。</li>
</ul>
</li>
<li>
<p>恢复进程</p>
<ul>
<li>当Gandiva客户端发出SIGCONT信号时，工具包会分配GPU内存，将存储的对象从CPU复制到GPU，并恢复进程。</li>
<li>为了处理重新启动时的<strong>地址改变</strong>，我们跟踪工具包中的GPU对象，并用新的地址对其进行修补。</li>
<li>改变GPU需要调用cudaDeviceReset和CudaInit，这可能需要5-10秒。我们通过在 &ldquo;暂停 &ldquo;时在后台执行这些操作来<strong>隐藏这个延时</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Tensorflow迁移</p>
<ul>
<li>我们在每个服务器上部署了一个迁移助手，以支持按需checkpoint和迁移。
<ul>
<li>当收到来自调度器的迁移命令时，目的地助手首先<strong>预热TF会话</strong>并等待检查点的到来。</li>
<li>然后，源帮助者要求TF保存检查点，在跨服务器迁移的情况下将检查点移到目的地，最后恢复训练会话。</li>
<li>为了加快迁移过程，我们采用Ramdisk将检查点保存在内存中。在跨服务器的情况下，修改后的TF通过网络文件系统（NFS）协议将检查点直接保存到远程Ramdisk。</li>
</ul>
</li>
<li>当Migration Helper要求作业执行checkpoint时
<ul>
<li>修改后的TF会在一个小批处理结束时调用tf.Saver。</li>
<li>对于数据的并行性，检查点只包括一个GPU中的模型，而不考虑训练中使用的GPU数量。</li>
<li>为了进一步加快TF的迁移，我们在检查点中不包括元图结构，因为它可以根据用户代码进行重建。</li>
</ul>
</li>
<li>在<strong>预热阶段</strong>，修改后的TF检查GPU配置并重建元图。
<ul>
<li>它进一步创建Executor来运行预热操作，以确保初始化不会被懒惰地推迟。</li>
<li>当恢复训练过程时，修改后的TF加载检查点，由多个GPU并行加载，并继续进行训练。</li>
</ul>
</li>
</ul>
</li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/gandiva/">Gandiva</a>
        
            <a href="/tags/%E8%AE%BA%E6%96%87/">论文</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="has-image">
    <a href="/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0easyscale%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211091510408.png" loading="lazy" data-key="" data-hash="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/202211091510408.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【论文笔记】EasyScale论文阅读笔记</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0gaiagpu%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220826142857.png" loading="lazy" data-key="" data-hash="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220826142857.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【论文笔记】GaiaGPU论文阅读笔记</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0polardb-serverless%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A/">
        
        
            <div class="article-image">
                
                    <img src="https://2021.sigmod.org/images/2021sigmod-logo1.jpg" loading="lazy" data-key="" data-hash="https://2021.sigmod.org/images/2021sigmod-logo1.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【论文笔记】PolarDB-Serverless论文阅读报告</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0antman%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220829154241.png" loading="lazy" data-key="" data-hash="https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/20220829154241.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【论文笔记】AntMan论文阅读笔记</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (DISQUS) {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2022 Tweakzx
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.5.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#abstract">Abstract</a></li>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#backgroud">Backgroud</a></li>
    <li><a href="#dlt-job的特征">DLT job的特征</a>
      <ol>
        <li><a href="#对位置locality敏感">对位置（locality)敏感</a></li>
        <li><a href="#对干扰敏感">对干扰敏感</a></li>
        <li><a href="#job内可预测性">job内可预测性</a></li>
      </ol>
    </li>
    <li><a href="#设计">设计</a>
      <ol>
        <li><a href="#机制">机制</a>
          <ol>
            <li><a href="#挂起-重启与装箱">挂起-重启与装箱</a></li>
            <li><a href="#迁移">迁移</a></li>
            <li><a href="#增长与收缩">增长与收缩</a></li>
            <li><a href="#profiling">Profiling</a></li>
          </ol>
        </li>
        <li><a href="#调度原则">调度原则</a>
          <ol>
            <li><a href="#响应模式">响应模式</a></li>
            <li><a href="#内省模式">内省模式</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#实现">实现</a>
      <ol>
        <li><a href="#调度器">调度器</a></li>
        <li><a href="#dl工具的修改">DL工具的修改</a></li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
