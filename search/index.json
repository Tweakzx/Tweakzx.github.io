[{"content":"1矩阵向量乘法（4分） 讲义55页所示结果Y，如果要作为下一次矩阵向量乘法的输入X，切分到不同的列进程，并且复制到每一行进程，应如何操作？可写出伪代码，或用语言描述。\n即图(a)中的Y，变成下图(b)中的X。假设每行有P个进程，每列也是P个进程，一共P*P个进程。\n\rimage-20211210120943046\r\n答：进程$P_{ij}$和所控制的矩阵进行矩阵向量乘之后，将结果存入进程$P_{ji}$。\n2 代码填空（3分） 在测量程序性能时，我们经常要记录整个程序或程序中某一部分的运行时间。在MPI程序中，由于每个进程的运行时间不同，一般需要取各个进程运行时间的最大值，然后由0号进程保存和打印（其他进程不需要保存）。以下程序完成了这个功能，请在横线处填上函数调用语句。\nint main(int argc, char * argv) { double total_time; double time0, time1; int procs, rank; MPI_init(argc, argv); MPI_Comm_size(MPI_COMM_WORLD, \u0026amp;procs); MPI_Comm_rank(MPI_COMM_WORLD, \u0026amp;rank); time0 = MPI_Wtime(); //do some computation \ttime1 = MPI_Wtime() – time0; _______________________________________________________________ if(rank == 0) { Printf(“Total execution time is %f seconds\\n”, total_time); } } 答：\nMPI_Reduce(\u0026amp;time1,\u0026amp;total_time,1,MPI_DOUBLE,MPI_MAX,0,MPI_COMM_WORLD) 3 以下程序相当于哪个MPI聚合操作？（3分） #define N 16384 double *send_buff, *recv_buff; MPI_Status status; int i, nprocs, myid, count=N/num_procs; send_buff = (double*)malloc(N*sizeof(double)); recv_buff = (double*)malloc(N*sizeof(double)); MPI_Comm_size(MPI_COMM_WORLD, \u0026amp;nprocs); MPI_Comm_rank(MPI_COMM_WORLD, \u0026amp;myid); //此处省略send_buff中数据的初始化 memcpy((void*)(recv_buff + myid * count), (void*)(send_buff + myid * count), count*sizeof(double)); for(int i = 0; i \u0026lt; nprocs;i++) { if(i!=myid) { MPI_Sendrecv(send_buff+i*count, count, MPI_DOUBLE, i, 400, recv_buff+i*count, count, MPI_DOUBLE, i, 400, MPI_COMM_WORLD, \u0026amp;status); } } 答：MPI_Alltoall()\n","date":"2021-12-10T11:28:33+08:00","image":"https://img2.baidu.com/it/u=2900542081,1673808678\u0026fm=26\u0026fmt=auto","permalink":"https://tweakzx.github.io/p/%E5%B9%B6%E8%A1%8C%E4%BD%9C%E4%B8%9A-1/","title":"并行作业 1"},{"content":"1 逻辑时钟与一致割集 下图中，直线上小黑点给出了时钟计数，请分别用Lamport 逻辑时钟和向量时钟给图上的事件设置时间戳，并给出一致割集和非一致割集的例子。\n\r事件时钟计数\r\n答：\n  设置时间戳\n  Lamport逻辑时钟\n\rLamport逻辑时钟\r\n  向量时钟\n\r向量时钟\r\n    割集的例子\n  一致割集\n\r一致割集\r\n  非一致割集\n\r非一致割集\r\n包含$e_1^2$这个接收事件但是不包含$e_3^1$这个发送事件。\n    2 异步分布式系统的故障类型 考虑在异步分布式系统中使用的两个通信服务。在服务A中，消息可能丢失、被复制或延迟，校验和仅应用到消息头。在服务B中，消息可能丢失、延迟或发送地太快以致接收方无法处理它，但到达目的地的消息其内容一定正确。描述每个服务会有的故障类型。根据对有效性和完整性的影响将故障分类。服务B能被描述成一个可靠的通信服务吗？\n答：\n  服务A会有的故障类型\n 遗漏故障  消息丢失   拜占庭故障  checksum仅仅应用到消息的head，消息的body可能发生损坏 消息重复   因为这是异步分布式系统，所以不会有时序故障。  遗漏故障的消息丢失破坏了有效性。拜占庭故障的可能损坏的消息以及重复的消息破坏了完整性。\n  服务B会有的故障类型\n 遗漏故障  消息丢失 发送地太快以致接收方无法处理它，接收遗漏   因为这是异步分布式系统，所以不会有时序故障。  服务B满足完整性，但是服务B消息发生的遗漏故障，不满足有效性，所以不是可靠的通信服务。\n  3 Ricart and Agrawala 算法 请证明Ricart-Agrawala的互斥算法满足ME2和ME3。\n ME2:进入或退出临界区的请求最终都会成功\nME3:如果一个进入临界区的请求发生在先，那么进入临界区也按此顺序\nRicart-Agrawala算法：\n 一个进程申请资源时向所有其他进程发出带有时间戳的申请报文； 一个进程收到申请报文后，答复这个申请，当且仅当：1）若不在临界区并且自己未申请进入临界区,或者2)自己虽然发出了申请报文，但自己的报文的时间戳大于收到的申请报文。如果已经在临界区，或者自己的申请发送在前，则在出临界区之前将所有的申请挂起。 申请资源的进程仅在收到其它所有进程的回答报文后才进入临界区使用资源； 一个进程使用完资源后，它向所有挂起的申请发送回答报文。   证明：\n 证明满足ME2  一个进程$p_i$要进入临界区向其他进程发送请求，不想进入临界区的进程，或者已经发送了请求但是发送时间戳大于接收请求时间戳$T_i$的进程都会回复。所以进程$p_i$要等待逻辑时间戳$T_i$之前发送了请求的进程以及正在临界区的进程的答复。 在逻辑时间戳$T_i$之前发出请求的进程所等待进程的数量依次递减到1。等正在临界区的进程使用完资源并退出后，所有在等待的进程所需等待进程数量全都减1。此时有一个进程得到了全部的答复，进入临界区。 按照这个过程，只要前边的进程依次进入临界区并退出之后，进程$p_i$就可以成功进入临界区，毕竟没有进程可以插队，所需等待进程数量只能递减。 由于使用完资源后退出临界区不需要等待答复，所以可以成功退出。所以，满足ME2。   证明满足ME3  当进$p_i$给其他进程发送进入临界区的申请时 如果进程$p_j$也想进入临界区，发送的申请的时间戳小于收到的$T_i$，那么$p_j$不会发送答复给$p_i$,这样$p_i$就必须等待$p_j$进入并退出临界区之后才能得到答复，才有可能进入临界区。 如果进程$p_j$也想进入临界区，发送的申请的时间戳大于收到的$T_i$，那么他会回复$p_i$的申请，$p_i$无需等待$p_j$，且当$p_i$收到$p_j$的请求之后不会回复，$p_j$等待$p_i$。 所以，满足ME3    4 改进Ricart and Agrawala 算法 在Ricart-Agrawala的互斥算法中，原始假定系统的进程是不出故障的。请修改算法增加处理一个进程崩溃的情况。\n答：如果有进程崩溃，那么它永远不会回复，则发送请求的进程需要一直盲等。\n 所以每当接收到消息之后要做出答复，回复同意，当且仅当：1）若不在临界区并且自己未申请进入临界区,或者2)自己虽然发出了申请报文，但自己的报文的时间戳大于收到的申请报文。或者回复拒绝，当1）自己处在临界区，或者2）自己的临界区申请的逻辑时间戳小于收到的申请，把回复拒绝的进程缓存起来，等待回复。 如果超出timeout没有收到答复则认为机器故障，只需等待其余的机器全部回复同意 当一个进程退出临界区之后，要向所有回复拒绝的进程回复同意。  5改进基于环的互斥算法 改进基于环的互斥算法使得它能检测权标的丢失并重新生成权标。\n答：\n 一个进程发出申请之后，如果长时间没有拿到权标，则向下一个节点发送一个请求reqest确认权标是否还在。 一个进程收到了确认权标存在的请求request，如果权标在自己手里则向下一个节点发送一个exist，如果权标不在自己手里，则将requst传递给下一个节点 一个进程收到了一个exist消息则将它传递到下一个节点 如果发出申请的进程收到request请求，则认为权标丢失，重新生成权标。如果收到exist，则说明一切正常。  6 双向环结构的选举算法 基于环的选举算法是建立在单向环的假设之上的，为了获得更快的选举速度，现采用双向环结构，即每个节点可以同时向顺时针和逆时针两个方向发送选举消息，请列出新算法的高层描述，并用一个四节点的双向环来说明你的方法。\n答：\n 最初，所有进程标记为非参与者，任意一个进程发起选举，发起选举后，置自己为参与者（$elected_i = ⊥$)，向上下游发送一个选举消息，包含自己的标识符。 一个进程收到选举消息后，那么比较自己的标识符与收到消息中的标识符，  如果自己的标识符小于消息中的标识符，那么顺消息来的方向传递选举消息； 如果自己的标识符大于消息中的标识符  如果自己是非参与者，将消息中的标识符改为自己标识符，顺消息来的方向传递选举消息。 如果自己是参与者，则不转发消息。   如果自己的标识符等于消息中的标识符，那么说明自己的标识符最大，如果还未当选，则当选为协调者，向上游和下游发送一个当选消息，包含自己的标识符P   一个进程收到一个当选消息，如果自己是参与者，设置$elected_i = P$，置自己为非参与者，并且按照消息发送的方向传递给自己的邻居；如果自己已经知晓当选消息，则不转发。  Init elected != ⊥ for process i (i = 1,2,...N) in the process which start an election: function startElection(): electingMSG \u0026lt;- MSG(type = \u0026quot;electing\u0026quot;, value = Local.id) Local.elected = '⊥' send(msg = electingMSG ,direction = clockwise) send(msg = electingMSG , direction = counterclockwise) in process i: function handleMSG(MSG msg, Direction direction): if msg.type = \u0026quot;electing\u0026quot;: if Local.id \u0026lt; msg.id: send(msg,direction) Local.elected = '⊥' else if Local.id \u0026gt; msg.id: if Local.elected != '⊥': msg.value = Local.id send(msg, direction) Local.elected = '⊥' end else if(process i is not Coordinator) setCoordinator(process i) Local.elected = '⊥' electdeMSG \u0026lt;- MSG(type = \u0026quot;elected\u0026quot;, value = Local.id) send(msg = electedMSG, direction = clockwise) send(msg = electedMSG, direction = counterclockwise) end end end if msg.type = \u0026quot;elected\u0026quot; if Local.elected == '⊥': Local.elected = msg.value send(msg, direction) end end \rimage-20211209165145519\r\n图中:\t白色表示初始非参与者，黄色表示参与者，红色表示知道当选结果。蓝色是选举消息，绿色是当选消息。从13号开始发起选举，最终选出23为协调者。\n 网络带宽：找到最大标识符最多需要N个消息，确认最大标识符最多需要2N个消息，通知当选最多需要N+1个消息，则最多需要消息为 4N+1 回转时间：第一轮寻找花费最多(N/2)个消息，第二轮确认需要最多花费N个消息，第三轮通知最多需要花费(N/2)+1个消息，所以最多需要花费2N+1个消息的回转时间。  7 基于生成树的选举算法 节点之间按照生成树方式连接，仅有边相连的节点能通信，请基于此网络拓扑，设计一个选举算法，给出其伪码。当仅有一个进程发起选举，你的选举算法所需的消息量是多少？\n答：假定是有向生成树，每个节点有父节点和子节点，每个节点可以向子节点或者父节点发送消息。任何一个进程都可以发起选举。算法如下：\n  收到选举消息，将发送消息的标识符和自己的标识符作比较，更改消息中的信息为较大值；如果有子节点，则向子节点发送这个选举消息；如果是叶子节点，则父亲节点返回一个回复消息，包含当前的较大标识符。\n  等到收到所有子节点的回复消息，选出最大的标识符，返回给父亲节点\n  当根节点收到最大的 标识符，则向所有的子节点发送当选信息，直到叶节点。如果有子节点发现自己的标识符等于消息中的的标识符，则成为协调者。\n  我的选举算法所需的消息量选举有N-1个，回复有N-1个，当选有N-1个，所以总共有3N-3个。\nInit Local.elected != ⊥ for process i (i = 1,2,...N) Local.count =0 for process i (i = 1,2,...N) in the process p0 which start an election: function startElection(): electingMSG \u0026lt;- MSG(type = \u0026quot;electing\u0026quot;, value = Local.id) Local.elected = '⊥' for i in son(p0): send(electingMSG, dest = i) end in process p: function handleMSG(MSG msg): if msg.type = \u0026quot;electing\u0026quot;: Local.elected = '⊥' if !isEmpty(son(p): msg.value = max(Local.id,msg.value) for i in son(p): send(msg, dest = i) end else replyMSG = MSG(type = \u0026quot;reply\u0026quot;, value = max(Local.id,msg.value) send(relpyMSG, dest = father(p)) end if msg.type = \u0026quot;reply\u0026quot;: Local.count++; msg.value = max(Local.id, msg.value) if(Local.count == son(p).size()): if !isEmpty(father(p)): send(msg, dest = father(p)) else electedMSG = MSG(type = \u0026quot;elected\u0026quot;,value = msg.value) for i in son(p): send(electedMSG, dest = i) end Local.elected = msg.value if Local.ip == msg.value: setCoordinator(process = p) end end end end if msg.type = \u0026quot;elected\u0026quot;: if Local.ip == msg.value: setCoordinator(process = p) end if !isEmpty(son(p)): for i in son(p): send(msg, dest = i) end end 8 法定数共识复制 在服务器X、Y和Z上使用法定数共识进行复制，这些服务器都有数据项A和B的副本。A和B副本的初始值是100，并且在X、Y和Z上A和B的选票是1。同样对于A和B，R＝W＝2。一个客户读A的值然后将它写到B上。\n1）当客户执行这些操作时，出现了一个分区，将服务器X和Y与服务器Z分隔开了。描述当客户能访问服务器X和Y时，获得的法定数和发生的操作。\n2）描述当客户仅能访问服务器Z时，获得的法定数和发生的操作。\n3）分区修复了，然后另一个分区发生了，结果X和Z与Y分隔开了。描述当客户能访问服务器X和Z时，获得的法定数和发生的操作。\n答：\n1）在数据的v0版本时，A和B副本的初始值是100，出现了一个分区，将服务器X和Y与服务器Z分隔开。\n   X Y Z     A = 100（v0) A = 100（v0) A = 100（v0)   B = 100（v0) B = 100（v0) B = 100（v0)    ​\t客户可能从X或者Y上读取A，R = 1+1 =2，读取成功。\n​\t客户需要在X和Y上写B，W = 1+1 = 2， 写成功。\n2)客户只能访问服务器Z，R = 1，客户无法读取；W = 1，客户无法写。\n3)当分区被修复后，因为之前的分区导致X和Y的数据要比Z上的数据更新，例如\n   X Y Z     A = 200（v1) A = 200（v1) A = 100（v0)   B = 300（v1) B = 300（v1) B = 100（v0)    此时，另一个分区出现，X和Z与Y分隔开，当客户试图获取法定数的时候，发现Z的数据版本过时，于是Z根据X上的最新数据更新自己。之后客户获取读法定数，R = 1+1 =2，然后读成功。客户获取写法定数，W = 1+1 =2，写成功。\n9 串行等价的交错执行 一个服务器管理对象a1, a2, \u0026hellip; an ，它为客户提供下面两种操作：read (i)返回对象ai的值。write(i, Value)将对象ai设置为值Value。\n事务T和U定义如下：\nT: x = read(j); y = read (i); write(j, 44); write(i, 33)\nU: x = read(k); write(i, 55); y = read (j); write(k, 66)\n请给出事务T和U的3个串行化等价的交错执行。\n答：我们给每一步分别表上序号：\nT: ①x = read(j); ②y = read (i); ③write(j, 44); ④write(i, 33)\nU: ⑤x = read(k); ⑥write(i, 55); ⑦y = read (j); ⑧write(k, 66)\n如果按照先T后U的顺序依次执行一个事务的话，我们发现①和⑤，②和⑦，④和⑥有写后写依赖；③和⑦有写后读依赖，①和③，②和④，②和⑥，⑤和⑧有读后写依赖，所以，我们要保证这些依赖的逻辑顺序，串行化等价的交错执行如下：\n①⑤②③④⑥⑦⑧\n①③⑤②④⑦⑧⑥\n①⑤③②⑧⑦④⑥\n10 乐观并发控制 考虑将乐观并发控制应用于下列事务T和U的情况：\n​ T: x = read(i); write(j, 44);\n​ U: write(i, 55); write(j, 66);\n如果事务T和U同时处于活动状态，试描述以下几种情况的结果如何：\n 服务器首先处理T的提交请求，使用向后验证方式。 服务器首先处理U的提交请求，使用向后验证方式。 服务器首先处理T的提交请求，使用向前验证方式。 服务器首先处理U的提交请求，使用向前验证方式。  对于上面的每种情况，描述事务T和U的操作顺序，注意写操作在验证通过之后才真正起作用。\n答：\n  服务器首先处理T的提交请求，使用向后验证方式。\nT先开始所以T的验证阶段无事发生，U进入验证阶段之后，U没有读集，所以没有冲突，可以顺利提交。\n  服务器首先处理U的提交请求，使用向后验证方式。\nT进入验证阶段，发现T的读集{i}与U的写集{i, j}有冲突，T事务被放弃。\n  服务器首先处理T的提交请求，使用向前验证方式。\nU进入验证阶段，发现U的写集{i,j}与T的读集{i}有冲突，所以推迟验证，等T的读集执行完毕之后再提交U。\n  服务器首先处理U的提交请求，使用向前验证方式。\nT进入验证阶段，发现U无读集，所以可以通过验证。\n  ","date":"2021-12-07T14:21:24+08:00","image":"https://img2.baidu.com/it/u=1163044150,1040852846\u0026fm=26\u0026fmt=auto","permalink":"https://tweakzx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A9%E5%9B%BA%E7%B1%BB%E4%BD%9C%E4%B8%9A/","title":"分布式巩固类作业"},{"content":" 时间：2021-12-2 下午5点半\n方式：阿里会议视频面试\n岗位：研究型实习生-智能存储\n 面试过程 这次面试主要是在聊项目，聊兴趣啥的。没有什么算法或者知识点的提问。\n 先做一下自我介绍。 问我觉得自己在学习上的最大优势是什么。 问我大三实习的主要工作，这一部分我还是忽略的带过了。 讲了自己的大二时的比赛。 问了可以实习的时间。 目前在学校里都学了什么课程。 面试官问我大四在做什么，我回答自己保研后在课题组里做结项的事情。面试官比较好奇我自己都做了什么，我回答东西都是别人做的，我就是提供一些辅助性的工作。 然后询问我课题组的主要研究是什么，我回答云计算，docker，k8s之类的。面试官问那为啥你做的东西和云计算一点关系都没有，又去做了算法NLP，我回答这是老师安排的。 问我对docker，k8s了解多少。我回答仅仅会简单的使用。 后来面试官解释NLP之类的工作一般是达摩院内边来做，意思可能是这边还是偏重于开发。 问我对这个部门的工作了解吗，一面有介绍吗？我回答和存储，预训练模型好像有关。 面试官说你要自己想好自己要做什么方向，兴趣是最好的老师啥的。（我也想啊） 面试官问我对NLP了解多少，我说仅仅毕业设计和这个有关，知道预训练和蒸馏。 他说感觉你对这些方面都有一点了解，但又都不深，不知道你将来要做什么。我回答自己目前还在探索，打算先开始做在去感受自己想要什么。 感觉聊到这里，其实已经无话可聊了。  下面是反问环节\n 我说自己可能问的问题比较大不好回答：如果我有机会得到这个offer，那我需要弥补的差距在什么地方？ 面试官从两个方面建议，一个就是如果计算想搞算法的话，blabla我忘了。如果想做开发的话，可以学习一下云原生，云计算之类的知识。 面试官分析了一下之后，我回答自己的理解与看法 ，主要说了人工智能是一种拿来应用的技术，做工程的过程中拿来使用，是工程的一部分。不是所有人都要去研究模型，我们能拿来即用即可，还是要去提升工程上的开发能力。  面试总结 我其实看不出来这次的结果好坏，面试官也确实提到了欢迎来去做一些尝试，可以先进来，实习的过程中摸索自己的兴趣，感受一下各个方向是什么样的，但更像是一些 说法正确的客套话。\n目前还在等结果。（希望结果是好的吧）\n","date":"2021-12-04T18:31:16+08:00","image":"https://img2.baidu.com/it/u=3334504742,937198599\u0026fm=26\u0026fmt=auto","permalink":"https://tweakzx.github.io/p/%E9%98%BF%E9%87%8C%E5%AE%9E%E4%B9%A0%E4%BA%8C%E9%9D%A2/","title":"阿里实习二面"},{"content":" 时间：2021-11-30 下午2点\n方式：阿里会议视频面试\n岗位：研究型实习生-智能存储\n 为什么会参加这次面试？ 因为想要亲身参与真实的科研活动或者一个真实企业内的做工程的过程，所以投递了这份简历，我也没有想到会给我安排面试。其实面试的时候我已经忘记自己投递的是哪个课题了，现在推测一下可能是大规模预训练模型的迁移啥的。\n因为面试的前一天参加了字节的面试，十分挫败，所以对面试可以说十分没有信心，加上收到的邮件里没有会议链接。无论面与不面，迟早要打电话告知，所以索性决定打电话推辞掉这个面试。打了电话，估计中午面试联系人可能在休息，所以过了一会才接到，面试联系人劝说我面试没有坏的影响，就当锻炼自己，只有好处没有坏处，不如一试。所以没有推脱，反正就一个小时，一个小时之后我的生活还会恢复原样。\n面试过程 面试的时候发现刚刚接电话的人应该就是面试官，面试官给我详细介绍了一下什么是研究型实习生以及它和其他的实习生的区别，以及对招聘的影响。然后就开始面试，先是自我介绍，还是介绍了本科，研究生的学校和专业，实习与比赛。问了我大概想做科研还是偏工程的方向，我回答工程，但后来想想应该回答我都行的其实。\n  面试了一道算法题：\n 将一个字符串按单词反转，但是对空间的开销有限制，最好是在原地址上直接修改，如果用栈，或者切割单词成数组之类的方式都是不符合空间开销要求的。\n 刚开始我想的是将单词先切出来，面试官发现我可能没有理解题目就又说了一下。\n我之后想说判断空格 然后做首尾交换，面试官提醒我单词的长度可能是不一致的，让我再想想。\n面试官说可以先说一下思路，再写代码。（说实话这点还挺赞的。）\n最后我想了想，说实话因为没有什么信心，我都想放弃算了。\n但偏偏还是想到了先把每个单词都先在局部反转，然后全局一起反转就不会产生大的空间开销。\n面试官说这个想法是对的，然后让我自己实现一下，就大概写了写代码。\n又问了我这个算法的时间复杂度是多少，我说是O(n)。\n  问平时怎么做测试，我回答用自己设计测试样例，然后print的方法和编辑器调试。\n他问我有么有用什么测试工具之类的，我说在课上学过UnitTest4，但实际上没用过。\n  知不知道多线程，pthread之类的。\n  之后聊了实习，实习时写的Json工具，日志接口开发。我都回答其实没有什么含金量。\n  然后是机器人大赛，路径规划算法用的是A* ,问我为什么用A* 而不是用机器人走迷宫的方式来操控机器人。和视觉算法的设计，以及OpenCV啥的。\n  最后聊了本科毕设，介绍了自己的毕设内容，问我觉得最有挑战的部分是啥。我回答是loss函数的设计，三段蒸馏，每段的不同的损失计算方法。\n  然后就是反问环节，我没问，确实不知道问啥。\n面试总结 大概就只记得这些了，好像忘记了很多其他的细节，但是面试完心情也比之前好了一些。\n阿里巴巴的这次面试给我最大的感受就是，面试官会确认自己的意思有没有准确传达给我，这个细节还挺令我感动的。面试官会把自己的问题或者很多要考虑的情况讲的很细致，确认我理解之后再让我思考并回答，这样其实对我这样不太熟悉面试的人十分友好的。\n面试的结果还不知道，但是无论好与坏，这次面试都给了我一些鼓舞，即便是结果不太好，我也不会气馁，不管怎么样都要继续努力。（希望结果是好的吧）\n后来接到了二面的电话，所以一面应该是过了。\n","date":"2021-12-01T21:49:57+08:00","image":"https://img2.baidu.com/it/u=3334504742,937198599\u0026fm=26\u0026fmt=auto","permalink":"https://tweakzx.github.io/p/%E9%98%BF%E9%87%8C%E7%A0%94%E7%A9%B6%E5%9E%8B%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95/","title":"阿里研究型实习生面试"},{"content":" 时间：2021-11-26 下午六点\n方式：飞书视频面试\n岗位：后端开发\n 为什么会面试蓝湖 心血来潮想要出去实习，在校友群内发了求助。24号中午，本科的同班同学涛神问我想不想试一试蓝湖，我想要一份实习来提升自己的代码水平，所以当然要抓住这次机会。\n所以中午抓紧时间写了一份简历交给了涛神帮忙内推。涛神问我要不要先准备一下，我说不了，早解决早轻松，可能是犯蠢了，也可能是太了解自己，我不是会好好规划复习的人，所以不如趁着热情直接上。\n面试的过程 面试官还是很温柔的，上来先让我做了一下自我介绍，我介绍了一下本科和硕士，以及一段实习经历，一段比赛经历。让说一下觉得最有有挑战性的工作？实习和比赛都很水，所以实话实说没啥亮点。\n算法题一道，写一下快排。当时代码没有跑起来，因为vscode好像更新了code runner的配置，所以没有跑起来，不过写的代码大概率全是bug，代码能力也是硬伤。\nclass Solution { public: int qsort(vector\u0026lt;int\u0026gt;\u0026amp; nums,int left,int right){ int l = left; int r = right; if(l\u0026gt;=r){ return l; } int randNum = rand()%(r-l+1)+l; int temp = nums[randNum]; nums[randNum] = nums[l]; nums[l] = temp; int pivot = nums[l]; while(l\u0026lt;r){ while(l\u0026lt;r\u0026amp;\u0026amp;nums[r]\u0026gt;pivot){ r--; } nums[l] = nums[r]; while(l\u0026lt;r\u0026amp;\u0026amp;nums[l]\u0026lt;=pivot){ l++; } nums[r] = nums[l]; } nums[l] = pivot; qsort(nums,left,l-1); qsort(nums,l+1,right); return l; } vector\u0026lt;int\u0026gt; sortArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { srand((unsigned)time(NULL)); qsort(nums,0,(int)nums.size()-1); return nums; } }; 然后问了一些基础问题：\n  Java和C++的区别有哪些\n  类的重写和重载\n  TCP通信的三次握手和四次挥手，为什么不能多一次或者少一次？\n  TCP长连接和短链接\n  TCP和UDP的区别\n  了解Cache吗？我答非所问，回答了操作系统的cache。\n  其实有可能是问http缓存\n  输入url地址浏览器的变化\n  问有么有用过数据库，对数据库了解多少，回答用过MySQL\n  为什么要用数据库？\n  简单介绍一下云计算是什么，为什么要用云计算\n  面试总结 面完就知道自己应该是凉了，果然12月1号收到了感谢信。其实还是老问题，自己的基础知识还是要在巩固一下可能要多看看面经，另外算法什么的还是要多加练习。\n后来涛神告诉我是HR觉得只有一个月多的实习时间太短了，不好安排。\n","date":"2021-12-01T20:56:54+08:00","image":"https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/image-20211201214555354.png","permalink":"https://tweakzx.github.io/p/%E8%93%9D%E6%B9%96%E9%9D%A2%E8%AF%95%E5%87%89%E7%BB%8F/","title":"蓝湖面试凉经"},{"content":" 时间：2021-11-29下午三点\n方式：飞书视频面试\n岗位：后端开发实习生-业务中台职位\n 为什么会投递字节实习 ​\t因为中科院的研究所大多不让实习，研二想去实习是一定不行的。但是研一在雁栖湖，课题组在海淀，我研一基本不参与科研，所以想要趁没人管的时候出去实习。因为将来大概率是做软开，所以想找一份后端开发的工作。在校友群里问了一下，有学长给了一个内推的机会，所以就有了这次一面。\n面试过程 ​\t面试官上来让我做了自我介绍之后就让我写代码做题。\n 题目一：链表1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6 转变成 链表1-\u0026gt;6-\u0026gt;2-\u0026gt;5-\u0026gt;3-\u0026gt;4\n大概意思就是将链表平分成两部分，前一部分顺序不变，后一部分反转后插空插入前一部分链表。\n ​\t说实话，自己的代码能力确实有点差，原本打算使用c++来写后来改成了Java，因为我想起Java里有LinkedList这个数据结构。理由有点荒诞哈，其实是我没有意识到要自己定义节点来实现链表，所以在想要写指针的时候就卡住了，完全不知道怎么给LinkedList的链表写指针。然后就尬住了，面试官无奈说那就换一道吧。\n 题目二：判断一个二叉树是否是平衡树\n ​\t题目不是很难，但是自己太久不写代码有些生疏了，写出来的程序不知道为什么没有编译通过。说实话，面试官让我自己实现一个单例来测试程序，其中爆出的各种错误，无一不揭示了我完全没有什么开发经验的事实，例如内部类放错了位置，static的编译问题，还有一个空指针异常。无疑是再次尬死了。\n​\t之后面试官让我讲一讲自己的项目经历，主要问了一下大三在华为的实习。可惜自己虽然实习了，但实际的工作很少，含金量也不高，面试官兴趣不大。\n​\t之后就是问我有没有什么想问他的，我已经不想说话了，就没问。\n​\t草草结束。\n总结 首先还是把这两道题的代码写写吧 题目一 /** * @author lizhixuan * @version 1.0 * @date 2021/12/1 15:50 */ public class ReverseList2 { public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode createInstance(int n){ ListNode head = new ListNode(1); ListNode current = head; for (int i = 2; i \u0026lt;= n; i++) { current.next = new ListNode(i); current = current.next; } return head; } public static void printList(ListNode head){ ListNode current = head; while(current.next!=null){ System.out.print(current.val); System.out.print(\u0026#34;-\u0026gt;\u0026#34;); current = current.next; } System.out.println(current.val); } public static ListNode reverse(ListNode head){ ListNode pre = null; ListNode current = head; ListNode next; while(current!=null){ next = current.next; current.next = pre; pre = current; current = next; } return pre; } public static ListNode mergeList(ListNode l1,ListNode l2){ ListNode head = l1; ListNode l1Next; ListNode l2Next; while(l1!=null\u0026amp;\u0026amp;l2!=null){ l1Next = l1.next; l2Next = l2.next; l1.next = l2; l2.next = l1Next; l1 = l1Next; l2 = l2Next; } return head; } public static ListNode reverseHalf(ListNode head){ ListNode fast = head; ListNode slow = head; while(fast != null){ if(fast.next == null){ break; } if(fast.next.next == null){ break; } fast = fast.next.next; slow = slow.next; } ListNode half = reverse(slow.next); slow.next = null; return mergeList(head,half); } public static void main(String[] args) { ListNode head = createInstance(7); printList(head); head = reverseHalf(head); printList(head); } } 题目二 import java.util.LinkedList; import java.util.Queue; /** * @author lizhixuan * @version 1.0 * @date 2021/12/1 17:24 */ public class BalanceCheck { public static class TreeNode{ int val; TreeNode left; TreeNode right; TreeNode(int val){this.val = val;} } public static TreeNode listToTree(String src){ src = src.substring(1,src.length()-1); String[] strList = src.split(\u0026#34;,\u0026#34;); TreeNode root ; TreeNode result = null; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i =0 ; i\u0026lt; strList.length ; i++){ if (i == 0){ root = new TreeNode(Integer.parseInt(strList[i])); result = root; queue.add(root); } if (!queue.isEmpty()){ root = queue.poll(); }else { break; } if ( i+1 \u0026lt; strList.length \u0026amp;\u0026amp; !strList[i+1].equals( \u0026#34;null\u0026#34;)){ root.left = new TreeNode(Integer.parseInt(strList[i +1])); queue.add(root.left); } if ( i + 2 \u0026lt; strList.length \u0026amp;\u0026amp; !strList[i+2].equals( \u0026#34;null\u0026#34;)){ root.right = new TreeNode(Integer.parseInt(strList[i +2])); queue.add(root.right); } i = i +1; } return result; } public static int getHeight(TreeNode root){ if(root==null){ return 0; } return Math.max(getHeight(root.left),getHeight(root.right))+1; } public static boolean isBalanced(TreeNode root){ if(root==null){ return true; } int leftHeight = getHeight(root.left); int rightHeight = getHeight(root.right); return Math.abs(leftHeight-rightHeight)\u0026lt;=1 \u0026amp;\u0026amp; isBalanced(root.left) \u0026amp;\u0026amp; isBalanced(root.right); } public static void main(String[] args) { String tree = \u0026#34;[3,9,20,null,null,15,7]\u0026#34;; TreeNode root = listToTree(tree); System.out.println(isBalanced(root)); } } 一些知识点   java内部类：\n 成员内部类中不能存在任何static的变量和方法 成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类    java的static关键字\n static变量也称作静态变量，静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。 为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。 在C/C++中static是可以作用域局部变量的，但是在Java中切记：static是不允许用来修饰局部变量。    反思  自己还是缺乏代码经验，代码写不出来，面试官明显十分失望，失去耐心之后多次叹气捂脸，说实话压力还是挺大的，毕竟确实挺丢脸的。以后也要多写一点代码。 打算把自己的学习总结下来，于是也有了这篇博客，希望自己可以坚持写博客，说实话，面试完压力挺大，感觉自己就是一个无敌铁废物，写博客写出来感觉好一些了。  ","date":"2021-11-29T16:52:26+08:00","image":"https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/bytedance.jpg","permalink":"https://tweakzx.github.io/p/%E5%AD%97%E8%8A%82%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E5%87%89%E7%BB%8F/","title":"字节实习面试凉经"}]