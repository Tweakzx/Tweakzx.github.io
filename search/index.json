[{"content":"安装 git yum install git 安装 docker curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun systemctl start docker 安装 make yum -y install gcc automake autoconf libtool make yum install gcc gcc-c++ 安装 K8s curl -LO \u0026#34;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\u0026#34; curl -LO \u0026#34;https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256\u0026#34; echo \u0026#34;$(cat kubectl.sha256)kubectl\u0026#34; | sha256sum --check sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl kubectl version --client 安装 go   Remove any previous Go installation  by deleting the /usr/local/go folder (if it exists), then extract the archive you just downloaded into /usr/local, creating a fresh Go tree in /usr/local/go:\n$ rm -rf /usr/local/go \u0026amp;\u0026amp; tar -C /usr/local -xzf go1.18.1.linux-amd64.tar.gz (You may need to run the command as root or through sudo).\nDo not untar the archive into an existing /usr/local/go tree. This is known to produce broken Go installations.\nAdd /usr/local/go/bin to the  PATH environment variable.\nYou can do this by adding the following line to your $HOME/.profile or /etc/profile (for a system-wide installation):\nexport PATH=$PATH:/usr/local/go/bin Note: Changes made to a profile file may not apply until the next time you log into your computer. To apply the changes immediately, just run the shell commands directly or execute them from the profile using a command such as source $HOME/.profile.\nVerify that you\u0026rsquo;ve installed Go by opening a command prompt and typing the following command:  $ go version Confirm that the command prints the installed version of Go.   wget https://go.dev/dl/go1.18.1.linux-amd64.tar.gz rm -rf /usr/local/go \u0026amp;\u0026amp; tar -C /usr/local -xzf go1.18.1.linux-amd64.tar.gz export PATH=$PATH:/usr/local/go/bin go version ","date":"2022-04-28T13:36:00+08:00","permalink":"https://tweakzx.github.io/p/%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83/","title":"安装环境"},{"content":"题目描述 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。\n函数 myAtoi(string s) 的算法如下：\n 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，\u0026ldquo;123\u0026rdquo; -\u0026gt; 123， \u0026ldquo;0032\u0026rdquo; -\u0026gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。  注意：\n  本题中的空白字符只包括空格字符 ' ' 。\n  除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。\n  示例 1：\n 输入：s = \u0026ldquo;42\u0026rdquo; 输出：42 解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。 第 1 步：\u0026ldquo;42\u0026rdquo;（当前没有读入字符，因为没有前导空格） ^ 第 2 步：\u0026ldquo;42\u0026rdquo;（当前没有读入字符，因为这里不存在 \u0026lsquo;-\u0026rsquo; 或者 \u0026lsquo;+'） ^ 第 3 步：\u0026ldquo;42\u0026rdquo;（读入 \u0026ldquo;42\u0026rdquo;） ^ 解析得到整数 42 。 由于 \u0026ldquo;42\u0026rdquo; 在范围 [-231, 231 - 1] 内，最终结果为 42 。\n 示例 2：\n 输入：s = \u0026quot; -42\u0026quot; 输出：-42 解释： 第 1 步：\u0026quot; -42\u0026quot;（读入前导空格，但忽视掉） ^ 第 2 步：\u0026quot; -42\u0026quot;（读入 \u0026lsquo;-\u0026rsquo; 字符，所以结果应该是负数） ^ 第 3 步：\u0026quot; -42\u0026quot;（读入 \u0026ldquo;42\u0026rdquo;） ^ 解析得到整数 -42 。 由于 \u0026ldquo;-42\u0026rdquo; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。\n 示例 3：\n 输入：s = \u0026ldquo;4193 with words\u0026rdquo; 输出：4193 解释： 第 1 步：\u0026ldquo;4193 with words\u0026rdquo;（当前没有读入字符，因为没有前导空格） ^ 第 2 步：\u0026ldquo;4193 with words\u0026rdquo;（当前没有读入字符，因为这里不存在 \u0026lsquo;-\u0026rsquo; 或者 \u0026lsquo;+'） ^ 第 3 步：\u0026ldquo;4193 with words\u0026rdquo;（读入 \u0026ldquo;4193\u0026rdquo;；由于下一个字符不是一个数字，所以读入停止） ^ 解析得到整数 4193 。 由于 \u0026ldquo;4193\u0026rdquo; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。\n 提示：\n 0 \u0026lt;= s.length \u0026lt;= 200 s 由英文字母（大写和小写）、数字（0-9）、\u0026rsquo; \u0026lsquo;、'+'、'-\u0026rsquo; 和 \u0026lsquo;.\u0026rsquo; 组成  来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/string-to-integer-atoi\n题解 大家可以自行去看leetcode的官方题解，就是用一个自动机来解决这个问题。我第一次用Go来解决这个问题，所以决定记录下来\ntype Automaton struct{ state string sign int ans int table map[string][]string } func(a *Automaton) init(){ //因为Go不能设置类型变量的初始值（我没找到相关代码），所以我用了初始化函数来代替  a.state = \u0026#34;start\u0026#34; a.sign = 1 a.ans = 0 a.table = map[string][]string{ \u0026#34;start\u0026#34; : []string{\u0026#34;start\u0026#34;,\u0026#34;signed\u0026#34;,\u0026#34;in_number\u0026#34;,\u0026#34;end\u0026#34;}, \u0026#34;signed\u0026#34; : []string{\u0026#34;end\u0026#34;,\u0026#34;end\u0026#34;,\u0026#34;in_number\u0026#34;,\u0026#34;end\u0026#34;}, \u0026#34;in_number\u0026#34; : []string{\u0026#34;end\u0026#34;,\u0026#34;end\u0026#34;,\u0026#34;in_number\u0026#34;,\u0026#34;end\u0026#34;}, \u0026#34;end\u0026#34; : []string{\u0026#34;end\u0026#34;,\u0026#34;end\u0026#34;,\u0026#34;end\u0026#34;,\u0026#34;end\u0026#34;}, } } func(a *Automaton) get(c byte){ //实现状态转移的方法  a.state = a.table[a.state][a.get_col(c)] switch a.state{ case \u0026#34;in_number\u0026#34;: a.ans = a.ans*10 + int(c-\u0026#39;0\u0026#39;) if a.sign\u0026gt;0{ a.ans = min(a.ans, math.MaxInt32) }else{ a.ans = min(a.ans, -math.MinInt32) } case \u0026#34;signed\u0026#34;: if c == \u0026#39;-\u0026#39;{ a.sign = -1 } } } func(a *Automaton) get_col(c byte ) int{//获得输入字符的类型  switch { case c==\u0026#39; \u0026#39;: return 0 case c==\u0026#39;+\u0026#39;||c==\u0026#39;-\u0026#39;: return 1 case \u0026#39;0\u0026#39;\u0026lt;=c\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;9\u0026#39;: return 2 default: return 3 } } func(a *Automaton) get_ans() int{ //获得结果  return a.sign * a.ans } func myAtoi(s string) int { a := \u0026amp;Automaton{} a.init() for i:=0; i\u0026lt;len(s); i++{ a.get(s[i]) } return a.get_ans() } func min(a,b int) int{ if a\u0026lt;b{ return a } return b } ","date":"2022-03-12T16:59:39+08:00","permalink":"https://tweakzx.github.io/p/%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0/","title":"自动机的实现"},{"content":"旅行起点 Go 语言之旅 (go-zh.org)\n上方链接是一个Go语言学习的Playground，快点击它，开启一场Go语言之旅吧\n旅行开始 练习：循环与函数 为了练习函数与循环，我们来实现一个平方根函数：用牛顿法实现平方根函数。\n计算机通常使用循环来计算 x 的平方根。从某个猜测的值 z 开始，我们可以根据 z² 与 x 的近似度来调整 z，产生一个更好的猜测：\nz -= (z*z - x) / (2*z) 重复调整的过程，猜测的结果会越来越精确，得到的答案也会尽可能接近实际的平方根。\n在提供的 func Sqrt 中实现它。无论输入是什么，对 z 的一个恰当的猜测为 1。 要开始，请重复计算 10 次并随之打印每次的 z 值。观察对于不同的值 x（1、2、3 \u0026hellip;）， 你得到的答案是如何逼近结果的，猜测提升的速度有多快。\n提示：用类型转换或浮点数语法来声明并初始化一个浮点数值：\nz := 1.0 z := float64(1) 然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数大于还是小于 10。 尝试改变 z 的初始猜测，如 x 或 x/2。你的函数结果与标准库中的 math.Sqrt 接近吗？\n（注： 如果你对该算法的细节感兴趣，上面的 z² − x 是 z² 到它所要到达的值（即 x）的距离， 除以的 2z 为 z² 的导数，我们通过 z² 的变化速度来改变 z 的调整量。 这种通用方法叫做牛顿法。 它对很多函数，特别是平方根而言非常有效。）\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func Sqrt(x float64) (z float64) { z = float64(1) for math.Abs(z*z-x)\u0026gt;0.000001 { z -= (z*z-x)/(z*2) } return } func main() { fmt.Println(Sqrt(2)) } 练习：切片 实现 Pic。它应当返回一个长度为 dy 的切片，其中每个元素是一个长度为 dx，元素类型为 uint8 的切片。当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像。\n图像的选择由你来定。几个有趣的函数包括 (x+y)/2, x*y, x^y, x*log(y) 和 x%(y+1)。\n（提示：需要使用循环来分配 [][]uint8 中的每个 []uint8；请使用 uint8(intValue) 在类型之间转换；你可能会用到 math 包中的函数。）\npackage main import \u0026#34;golang.org/x/tour/pic\u0026#34; func Pic(dx, dy int) [][]uint8 { picture := make([][]uint8,dy) for x:=range picture{ line := make([]uint8,dx) for y:=range line{ line[y] = uint8((x+y)/2) } picture[x] = line } return picture } func main() { pic.Show(Pic) } 练习：映射 实现 WordCount。它应当返回一个映射，其中包含字符串 s 中每个“单词”的个数。函数 wc.Test 会对此函数执行一系列测试用例，并输出成功还是失败。\n你会发现 strings.Fields 很有帮助。\npackage main import ( \u0026#34;golang.org/x/tour/wc\u0026#34; \u0026#34;strings\u0026#34; ) func WordCount(s string) map[string]int { words := strings.Fields(s) ans := make(map[string]int) for _,w :=range words{ //v,ok := ans[w] \tans[w] = ans[w] + 1 } return ans } func main() { wc.Test(WordCount) } 练习：斐波纳契闭包 让我们用函数做些好玩的事情。\n实现一个 fibonacci 函数，它返回一个函数（闭包），该闭包返回一个斐波纳契数列 (0, 1, 1, 2, 3, 5, ...)。\npackage main import \u0026#34;fmt\u0026#34; // 返回一个“返回int的函数” func fibonacci() func() int { first := 2 second := 1 //根据公式倒推出的first和second \treturn func() int{ first = second - first second = second + first //斐波那契公式 \treturn second } } func main() { f := fibonacci() for i := 0; i \u0026lt; 10; i++ { fmt.Println(f()) } } 练习：Stringer 通过让 IPAddr 类型实现 fmt.Stringer 来打印点号分隔的地址。\n例如，IPAddr{1, 2, 3, 4} 应当打印为 \u0026quot;1.2.3.4\u0026quot;。\npackage main import \u0026#34;fmt\u0026#34; type IPAddr [4]byte // TODO: 给 IPAddr 添加一个 \u0026#34;String() string\u0026#34; 方法 func (ip IPAddr) String() string{ return fmt.Sprintf(\u0026#34;%v.%v.%v.%v\\n\u0026#34;,ip[0],ip[1],ip[2],ip[3]) } func main() { hosts := map[string]IPAddr{ \u0026#34;loopback\u0026#34;: {127, 0, 0, 1}, \u0026#34;googleDNS\u0026#34;: {8, 8, 8, 8}, } for name, ip := range hosts { fmt.Printf(\u0026#34;%v: %v\\n\u0026#34;, name, ip) } } 练习：错误 从之前的练习中复制 Sqrt 函数，修改它使其返回 error 值。\nSqrt 接受到一个负数时，应当返回一个非 nil 的错误值。复数同样也不被支持。\n创建一个新的类型\ntype ErrNegativeSqrt float64 并为其实现\nfunc (e ErrNegativeSqrt) Error() string 方法使其拥有 error 值，通过 ErrNegativeSqrt(-2).Error() 调用该方法应返回 \u0026quot;cannot Sqrt negative number: -2\u0026quot;。\n注意: 在 Error 方法内调用 fmt.Sprint(e) 会让程序陷入死循环。可以通过先转换 e 来避免这个问题：fmt.Sprint(float64(e))。这是为什么呢？\n修改 Sqrt 函数，使其接受一个负数时，返回 ErrNegativeSqrt 值。\npackage main import ( \u0026#34;fmt\u0026#34; ) type ErrNegativeSqrt float64 func (e ErrNegativeSqrt) Error() string{ return fmt.Sprintf(\u0026#34;cannot Sqrt negative number: %v\u0026#34;,float64(e)) } func Sqrt(x float64) (float64, error) { if x\u0026gt;0{ return 0, nil }else{ var e ErrNegativeSqrt e = ErrNegativeSqrt(x) return x,e } } func main() { fmt.Println(Sqrt(2)) fmt.Println(Sqrt(-2)) } 练习：Reader 实现一个 Reader 类型，它产生一个 ASCII 字符 'A' 的无限流。\npackage main import \u0026#34;golang.org/x/tour/reader\u0026#34; type MyReader struct{} // TODO: 给 MyReader 添加一个 Read([]byte) (int, error) 方法 func (mr MyReader) Read(buf []byte) (int, error) { for i :=range buf{ buf[i] = \u0026#39;A\u0026#39; } return 1, nil } func main() { reader.Validate(MyReader{}) } 练习：rot13Reader 有种常见的模式是一个 io.Reader 包装另一个 io.Reader，然后通过某种方式修改其数据流。\n例如，gzip.NewReader 函数接受一个 io.Reader（已压缩的数据流）并返回一个同样实现了 io.Reader 的 *gzip.Reader（解压后的数据流）。\n编写一个实现了 io.Reader 并从另一个 io.Reader 中读取数据的 rot13Reader，通过应用 rot13 代换密码对数据流进行修改。\nrot13Reader 类型已经提供。实现 Read 方法以满足 io.Reader。\npackage main import ( \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) type rot13Reader struct { r io.Reader } func ( rot rot13Reader) Read(buf []byte) (int, error){ len,ok := rot.r.Read(buf) for i,v := range buf{ switch{ case (\u0026#39;a\u0026#39;\u0026lt;=v \u0026amp;\u0026amp; v\u0026lt;=\u0026#39;m\u0026#39;)||(\u0026#39;A\u0026#39;\u0026lt;=v \u0026amp;\u0026amp; v\u0026lt;=\u0026#39;M\u0026#39;): buf[i] = v+13 case (\u0026#39;n\u0026#39;\u0026lt;=v \u0026amp;\u0026amp; v\u0026lt;=\u0026#39;z\u0026#39;)||(\u0026#39;N\u0026#39;\u0026lt;=v \u0026amp;\u0026amp; v\u0026lt;=\u0026#39;Z\u0026#39;): buf[i] = v-13 default: } } return len,ok } func main() { s := strings.NewReader(\u0026#34;Lbh penpxrq gur pbqr!\u0026#34;) r := rot13Reader{s} io.Copy(os.Stdout, \u0026amp;r) } 练习：图像 还记得之前编写的图片生成器 吗？我们再来编写另外一个，不过这次它将会返回一个 image.Image 的实现而非一个数据切片。\n定义你自己的 Image 类型，实现必要的方法并调用 pic.ShowImage。\nBounds 应当返回一个 image.Rectangle ，例如 image.Rect(0, 0, w, h)。\nColorModel 应当返回 color.RGBAModel。\nAt 应当返回一个颜色。上一个图片生成器的值 v 对应于此次的 color.RGBA{v, v, 255, 255}。\npackage main import ( \u0026#34;golang.org/x/tour/pic\u0026#34; \u0026#34;image\u0026#34; \u0026#34;image/color\u0026#34; ) type Image struct{ w,h int pixels [][]uint8 } func (self Image) Bounds()(image.Rectangle){ return image.Rect(0, 0, self.w, self.h) } func (self Image) ColorModel()(color.Model){ return color.RGBAModel } func (self Image) At(x int ,y int)(color.Color){ v := self.pixels[y][x] return color.RGBA{v,v, 255, 255} } func Pic(dx, dy int) [][]uint8 { img := make([][]uint8, dy) for y := 0; y \u0026lt; dy; y++ { img[y] = make([]uint8, dx) for x := 0; x \u0026lt; dx; x++ { img[y][x] = (uint8)(x^y) } } return img } func main() { m := Image{256,256,Pic(256,256)} pic.ShowImage(m) } 练习：等价二叉查找树 1. 实现 Walk 函数。\n2. 测试 Walk 函数。\n函数 tree.New(k) 用于构造一个随机结构的已排序二叉查找树，它保存了值 k, 2k, 3k, \u0026hellip;, 10k。\n创建一个新的信道 ch 并且对其进行步进：\ngo Walk(tree.New(1), ch) 然后从信道中读取并打印 10 个值。应当是数字 1, 2, 3, ..., 10。\n3. 用 Walk 实现 Same 函数来检测 t1 和 t2 是否存储了相同的值。\n4. 测试 Same 函数。\nSame(tree.New(1), tree.New(1)) 应当返回 true，而 Same(tree.New(1), tree.New(2)) 应当返回 false。\nTree 的文档可在这里找到。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/tour/tree\u0026#34; ) // Walk 步进 tree t 将所有的值从 tree 发送到 channel ch。 func Walk(t *tree.Tree, ch chan int) { dfs(t, ch) close(ch) } func dfs(t *tree.Tree, ch chan int) { if t == nil { return } dfs(t.Left, ch) ch \u0026lt;- t.Value dfs(t.Right, ch) } // Same 检测树 t1 和 t2 是否含有相同的值。 func Same(t1, t2 *tree.Tree) bool { ch1, ch2 := make(chan int), make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) for i := range ch1 { // ch1 关闭后 for循环自动跳出 \tif i != \u0026lt;-ch2 { return false } } return true } func main() { fmt.Println(Same(tree.New(1), tree.New(1))) } 练习：Web 爬虫 在这个练习中，我们将会使用 Go 的并发特性来并行化一个 Web 爬虫。\n修改 Crawl 函数来并行地抓取 URL，并且保证不重复。\n提示：你可以用一个 map 来缓存已经获取的 URL，但是要注意 map 本身并不是并发安全的！\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) type Fetcher interface { // Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。 \tFetch(url string) (body string, urls []string, err error) } // Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。  type CrawlRecord struct{ m map[string]int mux sync.Mutex wg sync.WaitGroup } var\tcr = CrawlRecord{m: make(map[string]int)} func Crawl(url string, depth int, fetcher Fetcher) { defer cr.wg.Done() // TODO: 并行的抓取 URL。 \t// TODO: 不重复抓取页面。  // 下面并没有实现上面两种情况： \tif depth \u0026lt;= 0 { return } cr.mux.Lock() cr.m[url]++ cr.mux.Unlock() body, urls, err := fetcher.Fetch(url) if err != nil { fmt.Println(err) return } fmt.Printf(\u0026#34;found: %s %q\\n\u0026#34;, url, body) for _, u := range urls { cr.mux.Lock() if _,ok := cr.m[u]; !ok{ cr.wg.Add(1) go Crawl(u, depth-1, fetcher) } cr.mux.Unlock() } return } func main() { cr.wg.Add(1) Crawl(\u0026#34;https://golang.org/\u0026#34;, 4, fetcher) cr.wg.Wait() } // fakeFetcher 是返回若干结果的 Fetcher。 type fakeFetcher map[string]*fakeResult type fakeResult struct { body string urls []string } func (f fakeFetcher) Fetch(url string) (string, []string, error) { if res, ok := f[url]; ok { return res.body, res.urls, nil } return \u0026#34;\u0026#34;, nil, fmt.Errorf(\u0026#34;not found: %s\u0026#34;, url) } // fetcher 是填充后的 fakeFetcher。 var fetcher = fakeFetcher{ \u0026#34;https://golang.org/\u0026#34;: \u0026amp;fakeResult{ \u0026#34;The Go Programming Language\u0026#34;, []string{ \u0026#34;https://golang.org/pkg/\u0026#34;, \u0026#34;https://golang.org/cmd/\u0026#34;, }, }, \u0026#34;https://golang.org/pkg/\u0026#34;: \u0026amp;fakeResult{ \u0026#34;Packages\u0026#34;, []string{ \u0026#34;https://golang.org/\u0026#34;, \u0026#34;https://golang.org/cmd/\u0026#34;, \u0026#34;https://golang.org/pkg/fmt/\u0026#34;, \u0026#34;https://golang.org/pkg/os/\u0026#34;, }, }, \u0026#34;https://golang.org/pkg/fmt/\u0026#34;: \u0026amp;fakeResult{ \u0026#34;Package fmt\u0026#34;, []string{ \u0026#34;https://golang.org/\u0026#34;, \u0026#34;https://golang.org/pkg/\u0026#34;, }, }, \u0026#34;https://golang.org/pkg/os/\u0026#34;: \u0026amp;fakeResult{ \u0026#34;Package os\u0026#34;, []string{ \u0026#34;https://golang.org/\u0026#34;, \u0026#34;https://golang.org/pkg/\u0026#34;, }, }, } 旅行终点 你可以从安装 Go 开始。\n一旦安装了 Go，Go 文档是一个极好的 应当继续阅读的内容。 它包含了参考、指南、视频等等更多资料。\n了解如何组织 Go 代码并在其上工作，参阅此视频，或者阅读如何编写 Go 代码。\n如果你需要标准库方面的帮助，请参考包手册。如果是语言本身的帮助，阅读语言规范是件令人愉快的事情。\n进一步探索 Go 的并发模型，参阅 Go 并发模型(幻灯片)以及深入 Go 并发模型(幻灯片)并阅读通过通信共享内存的代码之旅。\n想要开始编写 Web 应用，请参阅一个简单的编程环境(幻灯片)并阅读编写 Web 应用的指南。\n函数：Go 中的一等公民展示了有趣的函数类型。\nGo 博客有着众多关于 Go 的文章和信息。\nmikespook 的博客中有大量中文的关于 Go 的文章和翻译。\n开源电子书 Go Web 编程和 Go 入门指南能够帮助你更加深入的了解和学习 Go 语言。\n访问 go-zh.org 了解更多内容。\n","date":"2022-02-22T17:20:32+08:00","image":"https://go.dev/images/gophers/biplane.svg","permalink":"https://tweakzx.github.io/p/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/","title":"Go语言之旅"},{"content":"PolarDB Serverless论文阅读报告 摘要 数据库管理系统的上云是近期很火的研究趋势，因为这样可以获得更高的弹性，可用性以及更低的成本，传统的独块的数据库架构很难满足这样的要求。高速网络与新的内存技术（例如RDMA）的发展，给分散式数据库带来了可能：它将原先的独块的服务器资源分离解耦到资源池中，再通过高速网络连接起来。下一代的云原生数据库就是为了分散化的数据中心而设计。\nPolarDB Serverless 遵循分散式的设计范式而设计，解耦了计算节点的CPU，内存，存储资源。\n 每种资源可以随需求而独立的增长或缩小，保障可靠性的同时，可以进行多维度的按需供应。 同时采用了优化策略如乐观锁和预取策略来改善性能。 还可以实现更快的故障恢复。  介绍 使用云数据库的三个好处：  按需付费可以使得用户减小开支。 更高的资源弹性可以应对短暂的资源使用高峰期。 更快的升级与更快的错误修复。快速的升级迭代可以保证产品竞争力，错误修复可以在不影响产品可用性的前提下进行。  经典的云数据库的架构  monolithic machine 独块的机器  特点：所有的资源都是紧耦合的 问题：  在进行数据库实例到机器的分发过程中要解决一个装箱问题 总是有碎片化的资源，难以达到高的使用率 运行时不能根据负载调整资源 资源间的命运共享，一个资源的故障会导致其他资源的故障，不能独立透明地修复故障，导致修复时间很长     存算分离的架构：  两种：  virtual machine with remote disk 搭载远程硬盘的虚拟机 shared storage 共享存储   优点  DBaaS可以提高存储池的使用率 共享存储可以进一步减少成本：原数据与只读备份可以共享存储   问题  CPU和内存的装箱问题依旧存在 缺乏灵活可放缩的内存资源 每个只读备份在内存中都要有冗余的内存开销      本文提出了一种新架构，分散架构（disaggragation architecture)  运行在分散的数据中心（DDC），CPU、内存和存储解耦，资源间通过高速网络连接 效果  每一种资源都可以提高其利用率，可以独立地放缩其资源量 解决了资源间的命运共享问题，资源故障可以被独立修复 数据页可以在远程内存池中被共享，所以解决了备份的内存冗余问题    云原生数据库 多数的云数据库是基于共享存储的架构，内存和CPU绑成最小的资源单元，只能按照最小资源单元的粒度来增长和释放资源，这会带来很多的资源浪费。\nPolarDB Serverless则是遵循分散架构的一个云原生数据库\n  引入了多租户可放缩的内存池，可以进行内存页的分配与生命周期管理\n  节点组成：\n 一个 RW node(存原数据页节点) 多个 RO node（存只读备份节点）    面临的挑战\n 添加远程内存之后，系统可以正确地处理事务  当写后读时，系统不应该错过任何一个update。使用缓存失效机制来保证写后所有地节点会更新 在更新B+树地索引的时候，使用global latch全局页锁来保证RO节点不能看到不一致的索引结构 使用读视图来确保RO节点不会读到未提交的事务   高效地执行事务  广泛使用了RDMA操作，尤其是one-sided RDMA verbs 为了提高并发，使用了乐观锁 存储方面使用了page materialization offloading技术，使用redo日志生成page 利用了预取来提高本地命中率   构建可信系统  对不同的节点都设计了策略来处理单点故障 因为内存和存储的状态是解耦的，所以修复崩溃的速度比独块架构要快5.3倍      背景 PolarDB PolarDB是一个基于共享内存架构云原生数据库\n PolarFS是一个持久化的原子操作的可伸缩的分布式共享存储。是统一的存储资源池，其提供虚拟的volume，每个volume划分为10GB大小的chunk分布在不同的节点。每个volume最多10000个chunk，即100T的容量。每个chunk三副本，用parallel raft提供线性一致性。 RW和RO节点之间通过redo日志来同步内存状态，通过LSN（log sequence number）来协调一致性。RW和RO节点上有负责处理SQL语句的处理器和事务引擎（InnoDB，X-Engine），以及一个缓存池来服务查询与事务。 有多个无状态的代理节点负责透明的负载均衡  \rimage-20211222201006368\r\n分散化的数据中心DDC   连接技术\n  在分散化的数据中心，计算节点、内存结点以及存储节点都是由高速网络连接。\n  RDMA（Remote Direct Memory Access）技术给大型的DDC带来了可能\n    层级结构\n 分为三层：spine layer、leaf layer、ToR layer 每一个ToR节点链接48台主机，ToR的交换机分别连接Leaf节点的交换机，然后Leaf的交换机又去链接Spine层的交换机。 每台主机都会配有双端口的RDMA网卡，用于链接两个ToR节点来避免单点故障。 一个leaf 交换机组包含互为备份的同时工作的多个leaf交换机 由一个leaf交换机组管理控制的所有的交换机与服务器称为一个PoD（Point of Delivery）。一个PoD最多有32个leaf交换机。    资源部署方式\n 单个数据库实例所需的内存和存储会部署在一个PoD下 不同实例部署在不同的PoD下 计算和内存资源总是倾向于部署在同一个ToR下，以获得更低的延迟与更少的页抖动    \rimage-20211222201043429\r\n无服务数据库 无服务数据库是云原生数据库的高弹性变种，主要目的是为了实现资源的按需分配\n 自动扩缩 auto-scaling  现存的无服务数据库的扩缩容因为是基于共享存储的架构，所以扩缩容受到限制。由于内存和CPU资源总是深度绑定在一个资源单位上，扩缩容也只能按照资源单位作为调动粒度。所以CPU和内存资源总是不能得到充分利用。 分析性数据库对内存的要求比较高，只需要少量的CPU资源来定期同步更新数据 事务性数据库少量的内存就可以保证缓存命中率，但需要更多的CPU资源来应对访问的高峰时刻   自动暂停 auto-pause  现存的无服务数据库的自动暂停也是受限的，CPU和内存资源必须被同时释放 在分散式架构下，CPU和内存不再共享命运。业务低峰期，内存可以不必释放，避免了重新加载。   扩容透明性 scaling transparency  透明性即在扩缩容的时候需要保证客户的场景不能中断或者性能出现严重影响 分散式架构下，中间临时状态如脏页、事务状态如版本信息timestamp、逻辑锁、query中间结果都可以保存在共享内存层，给实现扩缩容的透明性提供了更好的条件。 PolarDB Serverless 目前将脏页存在共享内存里，其他的临时状态期待后续的工作。    设计 PolarDB Serverless 基于PolarDB开发的分散式架构的云原生数据库。\n 组成：多个代理节点，一个RW节点，多个RO节点 使用PolarFS来做共享存储 和PolarDB的最大不同在于使用了远程内存池（共享内存）  使用共享内存\n 好处  RW和RO共用数据页，省去了每个节点自己保存副本，提高了内存的使用效率   坏处（performance penalty）  远程内存的访问速度远远低于本地内存；解决方案：分层内存系统和预取技术 私有数据放在公共资源上，需要有跨节点的互斥保护；解决方案：广泛使用单边的RDMA谓词和乐观协议来避免使用全局锁（global latch） 页的传输和网络带来了负担。解决方案：先将redo log写到存储层，再异步地通过日志将页物质化    分散化内存 远程内存访问接口  page_register: 页的引用计数增一 page_unregister: 页的引用计数减一 page_read: 使用单边RDMA谓词将页从远程内存读取到本地 page_write: 使用单边RDMA谓词将页从本地写到远程内存 page_invalidation: 使所有RO节点的本地的内存副本失效  远程内存管理 内存的分配单元是一个slab，一个slab的大小是1GB\n几种数据结构如下：\n Page Array（PA）  每一个slab由页数组组成，页数组是物理地址连续的由16KB的页组成的数组。 PA的地址会注册到RDMA的网卡上，所以可以被RDMA远程访问 负责提供slab访问的节点也叫slab node，第一个slab node 也叫home node   Page Address Table（PAT）  一个哈希表，存储每一页的位置（slab id 与物理地址）   Page Invalidation Bitmap (PIB)  一个位图，对应PAT的每一项记录invalidation bit，0表示内存中的是最新版本，1表示不是最新版本   Page Reference Directory(PRD)  一个map，对应于每个PAT项，记录引用了这个页的节点   Page Latch Table(PLT)  对于PAT中的每一项，管理其页锁（page latch）。 是一个全局的物理锁，用于多个数据库节点之间进行保护与同步读写 尤其用于保护B+树的结构一致性    page分配过程：\n 数据库向home node 发送page register请求 如果不存在，则遍历slab找到有空闲的slab，如果都没有空闲则使用LRU算法淘汰掉一些page 写入后，将page的为位置信息写入到PAT，返回page的远程地址和page latch  扩缩容：\n 扩容：home node 请求DBaaS分配新的slab，扩展buffer pool，PAT，PIB和PRD 缩容：page通过LRU进行淘汰，无用的slab将被回收  本地缓存  以page为单位将远程内存缓存到本地 如果page不在远程内存上，进程会从Polar FS读取内容到本地缓存，然后再写回到远程内存。（存储和内存不发生直接接触） 不是所有的page都要写入远程内存，例如全表扫描，这些page不太会再次访问 本地发生miss，进程要等待读取远程内存（可以利用预取技术） 本地的缓存写满后使用LRU算法进行淘汰。如果page没有修改过可以直接释放。如果page修改过，那就写回后再释放。引用计数减一。  缓存一致性  RO节点不能直接访问RW节点的本地缓存，只能通过获取最新的redo log来在本地物质化page来获取最新的数据。 如果RW节点将修改过的数据写回远程内存后，RO节点自然是不需要读取redo log，可是系统如果每次修改都要立刻写回，网络开销会很大。所以RW节点不会立刻写回，而是使用了页失效的方法。  \rimage-20211225120332727\r\n 具体过程如下：  RW修改page后，调用page_invalidation 发送请求到home node PIB中对应页项设置为1 查询PRD，查看page在哪些RO节点上存在 向所有的存在这个page的RO发送请求，将PIB设置为1 设置PIB过期是一个同步阻塞操作 只有全部的RO节点设置成功才返回成功 如果有个RO节点超时，那么就把他踢出集群来保证该操作成功   在写回到Polar FS（远程存储）的时候，同样会使用page_invalid来保证远程内存中不会存在比远程存储中更老版本的数据。  B+树结构一致性   物理一致性\n问题是：多线程访问B+树的Index的时候如何做到并发控制\n解决方案：\n  只有RW节点可以修改page，所以不需要管理多节点的写冲突。但是SMO（结构修改操作）会同时修改多个page，其他节点在遍历B+树的时候，不同的RO节点可能看到不一致的物理B+树结构。\n 我们使用全局页锁来解决这个问题，使用共享锁（S）和排他锁（X）。 区别于本地页锁，全局页锁用于保证多节点下的B+树索引结构一致性。使用crabbhing/lock coupling算法实现 所有参与SMO的节点会加上X锁，直到SMO结束。RO节点读取的时候要检查PLT，查看是否有X锁，并且向被读的页上加S锁。    对于RW节点要进行的insert和delete操作，我们采取两阶段做法\n 采用乐观并发控制，假设没有SMO操作，那就只需要本地的锁来作单节点并发控制。如果确实不需要进行SMO，那就顺利插入或者删除。 如果发现B+树的叶子节点相对空或者相对满，即很有可能要发生SMO操作，就启用悲观策略，这时候会对所有可能参与SMO的page加上X锁，直到SMO结束释放锁。这样锁的排序可以保证RO节点只能看到SMO之前或者之后的树结构，而不会是SMO的中间状态。      逻辑一致性\n 相同的数据可能会有多个事务进行并发处理，如何保证满足不同的快照隔离级别。    快照隔离 PolarDB Serverless 提供基于MVCC的快照隔离。事务的实现机制，是由快照的时间戳来控制事务能看到数据的版本信息。RW节点会维护一个中心化的的时间戳叫CTS，来为所有数据库节点分配全局单调递增的时间戳。\n一次读写事务需要获取两次时间戳（cts_read和cts_commit）；提交事务的时候所有记录和undo log中的记录都需要额外维护一个列来保存cts_commit;一个读写事务内的read总会返回一个cts_commit比cts_read要小的记录;每个记录都会有一个事务id字段来记录修改该记录的事务。\n一个只读事务则只需要在事务开始的时候获取cts_read时间戳即可。\n但是对于一些比较heavy的事务，无法迅速对所有记录更新cts_commit，因为这会在提交事务的时候带来大量的随机写。因此这个cts_commit的更新是异步执行的。这就导致了在并发事务处理的时候，无法得知该记录的cts_commit是否已经被写或者是否要被写，即无法得知先前的事务是否已经完成或者该记录是否与先前事务有关。\n解决方案：通过查询RW上的CTS Log数据结构，其是一个环形数组：记录着最近若干个的读写事务的提交时间戳(cts_commit)。如果先前事务没有完成，这个数组上的commit timestamp就会为null，每当一个节点读取到一个cts_commit为空的记录，就可以去查询这个全局的环形数组来得知这个记录对应的事务是否已经提交了。\n同样要去全局查这个时间戳要对应一次network request，本系统还是采用RDMA 来加速环形数组的访问获取时间戳的过程，RDMA CAS技术能够原子递增获取时间戳，并且这个数组的地址也会被注册到RDMA 的网卡上。和用RPC相比，直接走网卡不需要占用RW节点的CPU资源。\nPage Materialization Offloading 传统的DB会周期性的将脏页写入到持久性的存储中。Aurora提出了日志即数据库的概念，通过使用redo log来物质化页数据来获取最新版本的数据。Socrates在此基础上，则做到了将log与数据分离存储。\nPolarrDB Serverless和Socrates类似，将logs和pages分开存储在不同的chunks中。\n redo logs先存储在logs chunks中 异步发送到page chunks 为了PolarFS组件的重用和最小化更改，logs仅仅送到leader node。 然后leader node 重做并使用ParallelRaft保证副本的一致性  自动扩缩 在版本的升级和重启过程中，用户对Serverless服务是无感知的，断开连接，事务中断，请求超时是不允许的。\n所以在本系统中，当发生版本升级和跨节点迁移的时候，代理节点负责保持客户端连接，发送请求后会等待旧的RW节点处理掉正在进行的事务。之后把就节点的脏页flush到共享的内存池中，再关闭就RW节点。新的RW节点连接内存池，预热缓存，重做undo log来构建事务的列表。之后代理节点将连接还给新的RW节点。\n性能优化 使用分散式架构会带来性能的损失，所以要使用一些性能优化手段来进行优化。\n乐观锁 使用乐观锁可以尽可能避免并发操作对全局锁的获取，进而提高并行效率。\nRW节点会维护一个SMO counter，每次发生SMO的时候counter++；并且所有被修改的Page也会维护这个更新后的counter（SMO RW）\n每次query执行的时候去拿这个SMO counter（SMO query），一旦RO上的query发现某个Page的SMO counter比SMO query还要大，说明在query执行过程中发生了SMO。这个时候就要回滚到悲观并发控制，即获取全局PL来锁住整个B+ Tree的SMO更新。\n预取 在PolarDB Serverless中，我们提出了批处理密钥预处理(BKP)。BKP从分解的内存和存储中预取包含有趣的元组的页面，以隐藏远程I/O延迟。BKP的接口接受一组要预取的密钥。当调用该接口时，引擎将启动一个后台预取任务，从目标索引中检索所需的密钥，并在必要时从远程内存/存储中获取相应的数据页。BKP还可以优化分析工作负载。\n容错与恢复策略 数据库节点恢复 本系统采用的是ARIES的恢复算法（Algorithm for Recovery and Isolation Exploiting Semantics. ）\n RO节点的恢复：由于页数据再远程内存上，所以可以轻松地使用新的RO节点代替旧的RO节点 RW节点的恢复  无预期的节点故障  RW节点挂掉之后，集群的manager（CM）会通过心跳信号探测到，然后RO节点就可以晋升为RW节点。   有预期的节点故障  例如版本升级，前文已经讲过，不再赘述。      内存结点恢复 内存节点的数据缓存Page，在把dirty page写到内存节点前，对应的redo log已经flush到存储层了，因此内存节点重启可以用PolarFS上的redolog来进行恢复数据。\nhome node上因为包含重要的metadata如PAT，PIB，PRD和PLT；这些数据会同步备份在从副本；home node负责检测slab node上的故障，然后home node根据PAT上的信息来重建重启的slab node即可。\n集群恢复 在极少数情况下，当主节点的所有副本都不可用时，需要通过集群恢复来恢复服务。所有数据库节点和内存节点将从清除状态重新启动，所有内存状态将从存储重新启动。初始化后（连接到远程内存和存储器等），RW节点执行之前所述的并行REDO恢复，然后扫描撤销头以查找所有未完成的事务。之后，RW节点将启动服务，并在后台回滚未提交的事务。在集群恢复过程中，缓存在远程内存中的页面将被清除，因此它将忍受冷缓存问题。\n","date":"2021-12-22T14:17:12+08:00","image":"https://2021.sigmod.org/images/2021sigmod-logo1.jpg","permalink":"https://tweakzx.github.io/p/polardb-serverless%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A/","title":"PolarDB Serverless论文阅读报告"},{"content":"1 HPL（High Performance Linpack) 假设要使用HPL程序在4个进程上解一个4096 * 4096的方程组（4096 * 4096的矩阵加一列方程组的右端项b），按照讲义第14页所示的block-cyclic方式对数据进行分配，NB=512。4个进程按1 * 4和4 * 1两种方式排布。那么，在HPL的回代部分（讲义48到55页），X的各个元素分别是由哪些进程算出的？例如，X[0..512]由进程(3, 0)求出。写出两种排布方式下X的各部分分别由哪些进程计算得到。（5分）\n 1 * 4 排布  \rimage-20211214170301242\r\n   X 进程     X[0..511] (0,0)   X[512..1023] (0,1)   X[1024..1535] (0,2)   X[1536..2047] (0,3)   X[2048..2559] (0,0)   X[2560..3071] (0,1)   X[3072..3583] (0,2)   X[3584..4095] (0,3)     4 * 1 排布  \rimage-20211214170325158\r\n   X 进程     X[0..511] (0,0)   X[512..1023] (0,1)   X[1024..1535] (0,2)   X[1536..2047] (0,3)   X[2048..2559] (0,0)   X[2560..3071] (0,1)   X[3072..3583] (0,2)   X[3584..4095] (0,3)    ","date":"2021-12-14T13:55:35+08:00","image":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpmob0455c.pic27.websiteonline.cn%2Fupload%2Felinpack3000-1200_dps0.jpg\u0026refer=http%3A%2F%2Fpmob0455c.pic27.websiteonline.cn\u0026app=2002\u0026size=f9999,10000\u0026q=a80\u0026n=0\u0026g=0n\u0026fmt=jpeg?sec=1642054231\u0026t=55c0893a251868314596e23dae76a843","permalink":"https://tweakzx.github.io/p/%E5%B9%B6%E8%A1%8C%E4%BD%9C%E4%B8%9A-3/","title":"并行作业 3"},{"content":"1 加速向量加法 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt; inline cudaError_t checkCuda(cudaError_t result) { if (result != cudaSuccess) { fprintf(stderr, \u0026#34;CUDA Runtime Error: %s\\n\u0026#34;, cudaGetErrorString(result)); assert(result == cudaSuccess); } return result; } void initWith(float num, float *a, int N) { for(int i = 0; i \u0026lt; N; ++i) { a[i] = num; } } __global__ void addVectorsInto(float *result, float *a, float *b, int N) { int initIndex = threadIdx.x + blockIdx.x * blockDim.x; int gridStride = gridDim.x * blockDim.x; for(int i = initIndex;i\u0026lt;N;i+=gridStride){ result[i] = a[i] + b[i]; } } void checkElementsAre(float target, float *array, int N) { for(int i = 0; i \u0026lt; N; i++) { if(array[i] != target) { printf(\u0026#34;FAIL: array[%d] - %0.0f does not equal %0.0f\\n\u0026#34;, i, array[i], target); exit(1); } } printf(\u0026#34;SUCCESS! All values added correctly.\\n\u0026#34;); } int main() { const int N = 2\u0026lt;\u0026lt;20; size_t size = N * sizeof(float); float *a; float *b; float *c; cudaMallocManaged(\u0026amp;a, size); cudaMallocManaged(\u0026amp;b, size); cudaMallocManaged(\u0026amp;c, size); initWith(3, a, N); initWith(4, b, N); initWith(0, c, N); size_t threads_per_block = 1024; size_t number_of_blocks = (N+threads_per_block-1)/threads_per_block; addVectorsInto\u0026lt;\u0026lt;\u0026lt;32,1024\u0026gt;\u0026gt;\u0026gt;(c, a, b, N); //addVectorsInto\u0026lt;\u0026lt;\u0026lt;number_of_blocks,threads_per_block\u0026gt;\u0026gt;\u0026gt;(c, a, b, N);  checkCuda(cudaGetLastError()); checkCuda(cudaDeviceSynchronize()); checkElementsAre(7, c, N); cudaFree(a); cudaFree(b); cudaFree(c); } 2 加速SAXPY #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#define N 2048 * 2048 // Number of elements in each vector  /* * Optimize this already-accelerated codebase. Work iteratively, * and use nsys to support your work. * * Aim to profile `saxpy` (without modifying `N`) running under * 20us. * * Some bugs have been placed in this codebase for your edification. */ inline cudaError_t checkCuda(cudaError_t result) { if (result != cudaSuccess) { fprintf(stderr, \u0026#34;CUDA Runtime Error: %s\\n\u0026#34;, cudaGetErrorString(result)); assert(result == cudaSuccess); } return result; } __global__ void saxpy(float * a, float * b, float * c) { int tid = blockIdx.x * blockDim.x + threadIdx.x; int stride = gridDim.x * blockDim.x; for(int i = tid; i\u0026lt;N; i+=stride){ c[tid] = 2 * a[tid] + b[tid]; } } int main() { int deviceId; int numberOfSMs; cudaGetDevice(\u0026amp;deviceId); cudaDeviceGetAttribute(\u0026amp;numberOfSMs, cudaDevAttrMultiProcessorCount, deviceId); float *a, *b, *c; int size = N * sizeof (float); // The total number of bytes per vector  cudaMallocManaged(\u0026amp;a, size); cudaMallocManaged(\u0026amp;b, size); cudaMallocManaged(\u0026amp;c, size); // Initialize memory  for( int i = 0; i \u0026lt; N; ++i ) { a[i] = 2.0; b[i] = 1.0; c[i] = 0.0; } cudaMemPrefetchAsync(a, size, deviceId); cudaMemPrefetchAsync(b, size, deviceId); cudaMemPrefetchAsync(c, size, deviceId); int threads_per_block = 256; int number_of_blocks = numberOfSMs * 32 ; saxpy \u0026lt;\u0026lt;\u0026lt; number_of_blocks, threads_per_block \u0026gt;\u0026gt;\u0026gt; ( a, b, c ); checkCuda(cudaGetLastError()); checkCuda(cudaDeviceSynchronize()); // Print out the first and last 5 values of c for a quality check  for( int i = 0; i \u0026lt; 5; ++i ) printf(\u0026#34;c[%d] = %f, \u0026#34;, i, c[i]); printf (\u0026#34;\\n\u0026#34;); for( int i = N-5; i \u0026lt; N; ++i ) printf(\u0026#34;c[%d] = %f, \u0026#34;, i, c[i]); printf (\u0026#34;\\n\u0026#34;); cudaFree( a ); cudaFree( b ); cudaFree( c ); } 3 N-body #include \u0026lt;math.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026#34;timer.h\u0026#34;#include \u0026#34;files.h\u0026#34; #define SOFTENING 1e-9f  #include \u0026lt;assert.h\u0026gt;inline cudaError_t checkCuda(cudaError_t result) { if (result != cudaSuccess) { fprintf(stderr, \u0026#34;CUDA Runtime Error: %s\\n\u0026#34;, cudaGetErrorString(result)); assert(result == cudaSuccess); } return result; } /* * Each body contains x, y, and z coordinate positions, * as well as velocities in the x, y, and z directions. */ typedef struct { float x, y, z, vx, vy, vz; } Body; /* * Calculate the gravitational impact of all bodies in the system * on all others. */ __global__ void bodyForce(Body *p, float dt, int n) { int index = blockIdx.x * blockDim.x + threadIdx.x; int stride = gridDim.x * blockDim.x; for (int i = index; i \u0026lt; n; i+=stride) { float Fx = 0.0f; float Fy = 0.0f; float Fz = 0.0f; for (int j = 0; j \u0026lt; n; j++) { float dx = p[j].x - p[i].x; float dy = p[j].y - p[i].y; float dz = p[j].z - p[i].z; float distSqr = dx*dx + dy*dy + dz*dz + SOFTENING; float invDist = rsqrtf(distSqr); float invDist3 = invDist * invDist * invDist; Fx += dx * invDist3; Fy += dy * invDist3; Fz += dz * invDist3; } p[i].vx += dt*Fx; p[i].vy += dt*Fy; p[i].vz += dt*Fz; } } int main(const int argc, const char** argv) { // The assessment will test against both 2\u0026lt;11 and 2\u0026lt;15.  // Feel free to pass the command line argument 15 when you gernate ./nbody report files  int nBodies = 2\u0026lt;\u0026lt;11; if (argc \u0026gt; 1) nBodies = 2\u0026lt;\u0026lt;atoi(argv[1]); // The assessment will pass hidden initialized values to check for correctness.  // You should not make changes to these files, or else the assessment will not work.  const char * initialized_values; const char * solution_values; if (nBodies == 2\u0026lt;\u0026lt;11) { initialized_values = \u0026#34;files/initialized_4096\u0026#34;; solution_values = \u0026#34;files/solution_4096\u0026#34;; } else { // nBodies == 2\u0026lt;\u0026lt;15  initialized_values = \u0026#34;files/initialized_65536\u0026#34;; solution_values = \u0026#34;files/solution_65536\u0026#34;; } if (argc \u0026gt; 2) initialized_values = argv[2]; if (argc \u0026gt; 3) solution_values = argv[3]; const float dt = 0.01f; // Time step  const int nIters = 10; // Simulation iterations  int bytes = nBodies * sizeof(Body); float *buf; cudaMallocManaged(\u0026amp;buf, bytes); Body *p = (Body*)buf; read_values_from_file(initialized_values, buf, bytes); double totalTime = 0.0; /* * This simulation will run for 10 cycles of time, calculating gravitational * interaction amongst bodies, and adjusting their positions to reflect. */ int deviceId; int numberOfSMs; cudaGetDevice(\u0026amp;deviceId); cudaDeviceGetAttribute(\u0026amp;numberOfSMs, cudaDevAttrMultiProcessorCount, deviceId); int threads_per_block = 128; int number_of_blocks = numberOfSMs * 25 ; for (int iter = 0; iter \u0026lt; nIters; iter++) { StartTimer(); /* * You will likely wish to refactor the work being done in `bodyForce`, * and potentially the work to integrate the positions. */ bodyForce\u0026lt;\u0026lt;\u0026lt;threads_per_block,number_of_blocks\u0026gt;\u0026gt;\u0026gt;(p, dt, nBodies); // compute interbody forces  checkCuda(cudaGetLastError()); checkCuda(cudaDeviceSynchronize()); /* * This position integration cannot occur until this round of `bodyForce` has completed. * Also, the next round of `bodyForce` cannot begin until the integration is complete. */ for (int i = 0 ; i \u0026lt; nBodies; i++) { // integrate position  p[i].x += p[i].vx*dt; p[i].y += p[i].vy*dt; p[i].z += p[i].vz*dt; } const double tElapsed = GetTimer() / 1000.0; totalTime += tElapsed; } double avgTime = totalTime / (double)(nIters); float billionsOfOpsPerSecond = 1e-9 * nBodies * nBodies / avgTime; write_values_to_file(solution_values, buf, bytes); // You will likely enjoy watching this value grow as you accelerate the application,  // but beware that a failure to correctly synchronize the device might result in  // unrealistically high values.  printf(\u0026#34;%0.3f Billion Interactions / second\u0026#34;, billionsOfOpsPerSecond); cudaFree(buf); } 4 证书 \rimage\r\n","date":"2021-12-13T19:03:20+08:00","image":"https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/image-20211215144717123.png","permalink":"https://tweakzx.github.io/p/cuda%E5%8A%A0%E9%80%9F%E8%AF%BE%E7%A8%8B%E9%A2%98%E7%9B%AE/","title":"CUDA加速课程题目"},{"content":"1 矩阵向量乘法（6分） 矩阵向量乘法(gemv)如何用OpenMP或pthread对其并行化(OpenMP和pthread任选一种即可)？假设矩阵按行存储（每一行数据是连续的），处理器有32个核。如果矩阵是按列存储呢？具体实现如何修改？\n可用语言详细描述或写出伪代码\n  按行存储\nvoid *worker1(int row, int N, int** A, int* vec, int* result){ for(int i = row; i\u0026lt;N; i += 32){ result[i] = innerProduct(A[i],Vec); } } int main(){ ... for(int i=0;i\u0026lt;32;i++){ data_array[i].row = i; pthread_create(\u0026amp;threads[i], NULL, worker1, (void *)\u0026amp;data_array[i]) } ... }   按列存储\nvoid *worker2(int column, int N, int M, int** A, int* vec, int* result){ for(int j = column; j\u0026lt;M; j += 32){ for(int i = 0; i\u0026lt;N; i++){ result[i] += A[j][i]*Vec[j]; } } } int main(){ ... for(int i=0;i\u0026lt;32;i++){ data_array[i].column = i; pthread_create(\u0026amp;threads[i], NULL, worker1, (void *)\u0026amp;data_array[i]) } ... }   2 程序分析（4分） 以下程序运行时会出现什么现象？可以如何改写来避免此现象发生？\nint selected_thread; sem_t start1, start2, stop1, stop2; void* worker1() { sem_wait(\u0026amp;start1); sem_post(\u0026amp;stop1); } void *worker2(){ sem_wait(\u0026amp;start2); sem_post(\u0026amp;stop2); } int main(int argc, char *argv[]) { selected_thread = 2; sem_init(\u0026amp;start1); sem_init(\u0026amp;start2); sem_init(\u0026amp;stop1); sem_init(\u0026amp;stop2); pthread_create(worker1); pthread_create(worker2); sem_post(\u0026amp;start1); sem_wait(\u0026amp;stop1); sem_wait(\u0026amp;stop2); return 0; } 答： worker2会一直等待，程序无法结束。所以在主函数里加上sem_post(\u0026amp;start2)。\n","date":"2021-12-11T18:01:26+08:00","image":"https://pic1.zhimg.com/v2-f9d2f5486443cc045996753d59f80a7e_1440w.jpg?source=172ae18b","permalink":"https://tweakzx.github.io/p/%E5%B9%B6%E8%A1%8C%E4%BD%9C%E4%B8%9A-2/","title":"并行作业 2"},{"content":"1矩阵向量乘法（4分） 讲义55页所示结果Y，如果要作为下一次矩阵向量乘法的输入X，切分到不同的列进程，并且复制到每一行进程，应如何操作？可写出伪代码，或用语言描述。\n即图(a)中的Y，变成下图(b)中的X。假设每行有P个进程，每列也是P个进程，一共P*P个进程。\n\rimage-20211210120943046\r\n答：进程$P_{ij}$和所控制的矩阵进行矩阵向量乘之后，将结果存入进程$P_{ji}$。\n2 代码填空（3分） 在测量程序性能时，我们经常要记录整个程序或程序中某一部分的运行时间。在MPI程序中，由于每个进程的运行时间不同，一般需要取各个进程运行时间的最大值，然后由0号进程保存和打印（其他进程不需要保存）。以下程序完成了这个功能，请在横线处填上函数调用语句。\nint main(int argc, char * argv) { double total_time; double time0, time1; int procs, rank; MPI_init(argc, argv); MPI_Comm_size(MPI_COMM_WORLD, \u0026amp;procs); MPI_Comm_rank(MPI_COMM_WORLD, \u0026amp;rank); time0 = MPI_Wtime(); //do some computation \ttime1 = MPI_Wtime() – time0; _______________________________________________________________ if(rank == 0) { Printf(“Total execution time is %f seconds\\n”, total_time); } } 答：\nMPI_Reduce(\u0026amp;time1,\u0026amp;total_time,1,MPI_DOUBLE,MPI_MAX,0,MPI_COMM_WORLD) 3 以下程序相当于哪个MPI聚合操作？（3分） #define N 16384 double *send_buff, *recv_buff; MPI_Status status; int i, nprocs, myid, count=N/num_procs; send_buff = (double*)malloc(N*sizeof(double)); recv_buff = (double*)malloc(N*sizeof(double)); MPI_Comm_size(MPI_COMM_WORLD, \u0026amp;nprocs); MPI_Comm_rank(MPI_COMM_WORLD, \u0026amp;myid); //此处省略send_buff中数据的初始化 memcpy((void*)(recv_buff + myid * count), (void*)(send_buff + myid * count), count*sizeof(double)); for(int i = 0; i \u0026lt; nprocs;i++) { if(i!=myid) { MPI_Sendrecv(send_buff+i*count, count, MPI_DOUBLE, i, 400, recv_buff+i*count, count, MPI_DOUBLE, i, 400, MPI_COMM_WORLD, \u0026amp;status); } } 答：MPI_Alltoall()\n","date":"2021-12-10T11:28:33+08:00","image":"https://img2.baidu.com/it/u=2900542081,1673808678\u0026fm=26\u0026fmt=auto","permalink":"https://tweakzx.github.io/p/%E5%B9%B6%E8%A1%8C%E4%BD%9C%E4%B8%9A-1/","title":"并行作业 1"},{"content":"1 逻辑时钟与一致割集 下图中，直线上小黑点给出了时钟计数，请分别用Lamport 逻辑时钟和向量时钟给图上的事件设置时间戳，并给出一致割集和非一致割集的例子。\n\r事件时钟计数\r\n答：\n  设置时间戳\n  Lamport逻辑时钟\n\rLamport逻辑时钟\r\n  向量时钟\n\r向量时钟\r\n    割集的例子\n  一致割集\n\r一致割集\r\n  非一致割集\n\r非一致割集\r\n包含$e_1^2$这个接收事件但是不包含$e_3^1$这个发送事件。\n    2 异步分布式系统的故障类型 考虑在异步分布式系统中使用的两个通信服务。在服务A中，消息可能丢失、被复制或延迟，校验和仅应用到消息头。在服务B中，消息可能丢失、延迟或发送地太快以致接收方无法处理它，但到达目的地的消息其内容一定正确。描述每个服务会有的故障类型。根据对有效性和完整性的影响将故障分类。服务B能被描述成一个可靠的通信服务吗？\n答：\n  服务A会有的故障类型\n 遗漏故障  消息丢失   拜占庭故障  checksum仅仅应用到消息的head，消息的body可能发生损坏 消息重复   因为这是异步分布式系统，所以不会有时序故障。  遗漏故障的消息丢失破坏了有效性。拜占庭故障的可能损坏的消息以及重复的消息破坏了完整性。\n  服务B会有的故障类型\n 遗漏故障  消息丢失 发送地太快以致接收方无法处理它，接收遗漏   因为这是异步分布式系统，所以不会有时序故障。  服务B满足完整性，但是服务B消息发生的遗漏故障，不满足有效性，所以不是可靠的通信服务。\n  3 Ricart and Agrawala 算法 请证明Ricart-Agrawala的互斥算法满足ME2和ME3。\n ME2:进入或退出临界区的请求最终都会成功\nME3:如果一个进入临界区的请求发生在先，那么进入临界区也按此顺序\nRicart-Agrawala算法：\n 一个进程申请资源时向所有其他进程发出带有时间戳的申请报文； 一个进程收到申请报文后，答复这个申请，当且仅当：1）若不在临界区并且自己未申请进入临界区,或者2)自己虽然发出了申请报文，但自己的报文的时间戳大于收到的申请报文。如果已经在临界区，或者自己的申请发送在前，则在出临界区之前将所有的申请挂起。 申请资源的进程仅在收到其它所有进程的回答报文后才进入临界区使用资源； 一个进程使用完资源后，它向所有挂起的申请发送回答报文。   证明：\n 证明满足ME2  一个进程$p_i$要进入临界区向其他进程发送请求，不想进入临界区的进程，或者已经发送了请求但是发送时间戳大于接收请求时间戳$T_i$的进程都会回复。所以进程$p_i$要等待逻辑时间戳$T_i$之前发送了请求的进程以及正在临界区的进程的答复。 在逻辑时间戳$T_i$之前发出请求的进程所等待进程的数量依次递减到1。等正在临界区的进程使用完资源并退出后，所有在等待的进程所需等待进程数量全都减1。此时有一个进程得到了全部的答复，进入临界区。 按照这个过程，只要前边的进程依次进入临界区并退出之后，进程$p_i$就可以成功进入临界区，毕竟没有进程可以插队，所需等待进程数量只能递减。 由于使用完资源后退出临界区不需要等待答复，所以可以成功退出。所以，满足ME2。   证明满足ME3  当进$p_i$给其他进程发送进入临界区的申请时 如果进程$p_j$也想进入临界区，发送的申请的时间戳小于收到的$T_i$，那么$p_j$不会发送答复给$p_i$,这样$p_i$就必须等待$p_j$进入并退出临界区之后才能得到答复，才有可能进入临界区。 如果进程$p_j$也想进入临界区，发送的申请的时间戳大于收到的$T_i$，那么他会回复$p_i$的申请，$p_i$无需等待$p_j$，且当$p_i$收到$p_j$的请求之后不会回复，$p_j$等待$p_i$。 所以，满足ME3    4 改进Ricart and Agrawala 算法 在Ricart-Agrawala的互斥算法中，原始假定系统的进程是不出故障的。请修改算法增加处理一个进程崩溃的情况。\n答：如果有进程崩溃，那么它永远不会回复，则发送请求的进程需要一直盲等。\n 所以每当接收到消息之后要做出答复，回复同意，当且仅当：1）若不在临界区并且自己未申请进入临界区,或者2)自己虽然发出了申请报文，但自己的报文的时间戳大于收到的申请报文。或者回复拒绝，当1）自己处在临界区，或者2）自己的临界区申请的逻辑时间戳小于收到的申请，把回复拒绝的进程缓存起来，等待回复。 如果超出timeout没有收到答复则认为机器故障，只需等待其余的机器全部回复同意 当一个进程退出临界区之后，要向所有回复拒绝的进程回复同意。  5改进基于环的互斥算法 改进基于环的互斥算法使得它能检测权标的丢失并重新生成权标。\n答：\n 一个进程发出申请之后，如果长时间没有拿到权标，则向下一个节点发送一个请求reqest确认权标是否还在。 一个进程收到了确认权标存在的请求request，如果权标在自己手里则向下一个节点发送一个exist，如果权标不在自己手里，则将requst传递给下一个节点 一个进程收到了一个exist消息则将它传递到下一个节点 如果发出申请的进程收到request请求，则认为权标丢失，重新生成权标。如果收到exist，则说明一切正常。  6 双向环结构的选举算法 基于环的选举算法是建立在单向环的假设之上的，为了获得更快的选举速度，现采用双向环结构，即每个节点可以同时向顺时针和逆时针两个方向发送选举消息，请列出新算法的高层描述，并用一个四节点的双向环来说明你的方法。\n答：\n 最初，所有进程标记为非参与者，任意一个进程发起选举，发起选举后，置自己为参与者（$elected_i = ⊥$)，向上下游发送一个选举消息，包含自己的标识符。 一个进程收到选举消息后，那么比较自己的标识符与收到消息中的标识符，  如果自己的标识符小于消息中的标识符，那么顺消息来的方向传递选举消息； 如果自己的标识符大于消息中的标识符  如果自己是非参与者，将消息中的标识符改为自己标识符，顺消息来的方向传递选举消息。 如果自己是参与者，则不转发消息。   如果自己的标识符等于消息中的标识符，那么说明自己的标识符最大，如果还未当选，则当选为协调者，向上游和下游发送一个当选消息，包含自己的标识符P   一个进程收到一个当选消息，如果自己是参与者，设置$elected_i = P$，置自己为非参与者，并且按照消息发送的方向传递给自己的邻居；如果自己已经知晓当选消息，则不转发。  Init elected != ⊥ for process i (i = 1,2,...N) in the process which start an election: function startElection(): electingMSG \u0026lt;- MSG(type = \u0026quot;electing\u0026quot;, value = Local.id) Local.elected = '⊥' send(msg = electingMSG ,direction = clockwise) send(msg = electingMSG , direction = counterclockwise) in process i: function handleMSG(MSG msg, Direction direction): if msg.type = \u0026quot;electing\u0026quot;: if Local.id \u0026lt; msg.id: send(msg,direction) Local.elected = '⊥' else if Local.id \u0026gt; msg.id: if Local.elected != '⊥': msg.value = Local.id send(msg, direction) Local.elected = '⊥' end else if(process i is not Coordinator) setCoordinator(process i) Local.elected = '⊥' electdeMSG \u0026lt;- MSG(type = \u0026quot;elected\u0026quot;, value = Local.id) send(msg = electedMSG, direction = clockwise) send(msg = electedMSG, direction = counterclockwise) end end end if msg.type = \u0026quot;elected\u0026quot; if Local.elected == '⊥': Local.elected = msg.value send(msg, direction) end end \rimage-20211209165145519\r\n图中:\t白色表示初始非参与者，黄色表示参与者，红色表示知道当选结果。蓝色是选举消息，绿色是当选消息。从13号开始发起选举，最终选出23为协调者。\n 网络带宽：找到最大标识符最多需要N个消息，确认最大标识符最多需要2N个消息，通知当选最多需要N+1个消息，则最多需要消息为 4N+1 回转时间：第一轮寻找花费最多(N/2)个消息，第二轮确认需要最多花费N个消息，第三轮通知最多需要花费(N/2)+1个消息，所以最多需要花费2N+1个消息的回转时间。  7 基于生成树的选举算法 节点之间按照生成树方式连接，仅有边相连的节点能通信，请基于此网络拓扑，设计一个选举算法，给出其伪码。当仅有一个进程发起选举，你的选举算法所需的消息量是多少？\n答：假定是有向生成树，每个节点有父节点和子节点，每个节点可以向子节点或者父节点发送消息。任何一个进程都可以发起选举。算法如下：\n  收到选举消息，将发送消息的标识符和自己的标识符作比较，更改消息中的信息为较大值；如果有子节点，则向子节点发送这个选举消息；如果是叶子节点，则父亲节点返回一个回复消息，包含当前的较大标识符。\n  等到收到所有子节点的回复消息，选出最大的标识符，返回给父亲节点\n  当根节点收到最大的 标识符，则向所有的子节点发送当选信息，直到叶节点。如果有子节点发现自己的标识符等于消息中的的标识符，则成为协调者。\n  我的选举算法所需的消息量选举有N-1个，回复有N-1个，当选有N-1个，所以总共有3N-3个。\nInit Local.elected != ⊥ for process i (i = 1,2,...N) Local.count =0 for process i (i = 1,2,...N) in the process p0 which start an election: function startElection(): electingMSG \u0026lt;- MSG(type = \u0026quot;electing\u0026quot;, value = Local.id) Local.elected = '⊥' for i in son(p0): send(electingMSG, dest = i) end in process p: function handleMSG(MSG msg): if msg.type = \u0026quot;electing\u0026quot;: Local.elected = '⊥' if !isEmpty(son(p): msg.value = max(Local.id,msg.value) for i in son(p): send(msg, dest = i) end else replyMSG = MSG(type = \u0026quot;reply\u0026quot;, value = max(Local.id,msg.value) send(relpyMSG, dest = father(p)) end if msg.type = \u0026quot;reply\u0026quot;: Local.count++; msg.value = max(Local.id, msg.value) if(Local.count == son(p).size()): if !isEmpty(father(p)): send(msg, dest = father(p)) else electedMSG = MSG(type = \u0026quot;elected\u0026quot;,value = msg.value) for i in son(p): send(electedMSG, dest = i) end Local.elected = msg.value if Local.ip == msg.value: setCoordinator(process = p) end end end end if msg.type = \u0026quot;elected\u0026quot;: if Local.ip == msg.value: setCoordinator(process = p) end if !isEmpty(son(p)): for i in son(p): send(msg, dest = i) end end 8 法定数共识复制 在服务器X、Y和Z上使用法定数共识进行复制，这些服务器都有数据项A和B的副本。A和B副本的初始值是100，并且在X、Y和Z上A和B的选票是1。同样对于A和B，R＝W＝2。一个客户读A的值然后将它写到B上。\n1）当客户执行这些操作时，出现了一个分区，将服务器X和Y与服务器Z分隔开了。描述当客户能访问服务器X和Y时，获得的法定数和发生的操作。\n2）描述当客户仅能访问服务器Z时，获得的法定数和发生的操作。\n3）分区修复了，然后另一个分区发生了，结果X和Z与Y分隔开了。描述当客户能访问服务器X和Z时，获得的法定数和发生的操作。\n答：\n1）在数据的v0版本时，A和B副本的初始值是100，出现了一个分区，将服务器X和Y与服务器Z分隔开。\n   X Y Z     A = 100（v0) A = 100（v0) A = 100（v0)   B = 100（v0) B = 100（v0) B = 100（v0)    ​\t客户可能从X或者Y上读取A，R = 1+1 =2，读取成功。\n​\t客户需要在X和Y上写B，W = 1+1 = 2， 写成功。\n2)客户只能访问服务器Z，R = 1，客户无法读取；W = 1，客户无法写。\n3)当分区被修复后，因为之前的分区导致X和Y的数据要比Z上的数据更新，例如\n   X Y Z     A = 200（v1) A = 200（v1) A = 100（v0)   B = 300（v1) B = 300（v1) B = 100（v0)    此时，另一个分区出现，X和Z与Y分隔开，当客户试图获取法定数的时候，发现Z的数据版本过时，于是Z根据X上的最新数据更新自己。之后客户获取读法定数，R = 1+1 =2，然后读成功。客户获取写法定数，W = 1+1 =2，写成功。\n9 串行等价的交错执行 一个服务器管理对象a1, a2, \u0026hellip; an ，它为客户提供下面两种操作：read (i)返回对象ai的值。write(i, Value)将对象ai设置为值Value。\n事务T和U定义如下：\nT: x = read(j); y = read (i); write(j, 44); write(i, 33)\nU: x = read(k); write(i, 55); y = read (j); write(k, 66)\n请给出事务T和U的3个串行化等价的交错执行。\n答：我们给每一步分别表上序号：\nT: ①x = read(j); ②y = read (i); ③write(j, 44); ④write(i, 33)\nU: ⑤x = read(k); ⑥write(i, 55); ⑦y = read (j); ⑧write(k, 66)\n如果按照先T后U的顺序依次执行一个事务的话，我们发现①和⑤，②和⑦，④和⑥有写后写依赖；③和⑦有写后读依赖，①和③，②和④，②和⑥，⑤和⑧有读后写依赖，所以，我们要保证这些依赖的逻辑顺序，串行化等价的交错执行如下：\n①⑤②③④⑥⑦⑧\n①③⑤②④⑦⑧⑥\n①⑤③②⑧⑦④⑥\n10 乐观并发控制 考虑将乐观并发控制应用于下列事务T和U的情况：\n​ T: x = read(i); write(j, 44);\n​ U: write(i, 55); write(j, 66);\n如果事务T和U同时处于活动状态，试描述以下几种情况的结果如何：\n 服务器首先处理T的提交请求，使用向后验证方式。 服务器首先处理U的提交请求，使用向后验证方式。 服务器首先处理T的提交请求，使用向前验证方式。 服务器首先处理U的提交请求，使用向前验证方式。  对于上面的每种情况，描述事务T和U的操作顺序，注意写操作在验证通过之后才真正起作用。\n答：\n  服务器首先处理T的提交请求，使用向后验证方式。\nT先开始所以T的验证阶段无事发生，U进入验证阶段之后，U没有读集，所以没有冲突，可以顺利提交。\n  服务器首先处理U的提交请求，使用向后验证方式。\nT进入验证阶段，发现T的读集{i}与U的写集{i, j}有冲突，T事务被放弃。\n  服务器首先处理T的提交请求，使用向前验证方式。\nU进入验证阶段，发现U的写集{i,j}与T的读集{i}有冲突，所以推迟验证，等T的读集执行完毕之后再提交U。\n  服务器首先处理U的提交请求，使用向前验证方式。\nT进入验证阶段，发现U无读集，所以可以通过验证。\n  ","date":"2021-12-07T14:21:24+08:00","image":"https://img2.baidu.com/it/u=1163044150,1040852846\u0026fm=26\u0026fmt=auto","permalink":"https://tweakzx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A9%E5%9B%BA%E7%B1%BB%E4%BD%9C%E4%B8%9A/","title":"分布式巩固类作业"},{"content":" 时间：2021-12-2 下午5点半\n方式：阿里会议视频面试\n岗位：研究型实习生-智能存储\n 面试过程 这次面试主要是在聊项目，聊兴趣啥的。没有什么算法或者知识点的提问。\n 先做一下自我介绍。 问我觉得自己在学习上的最大优势是什么。 问我大三实习的主要工作，这一部分我还是忽略的带过了。 讲了自己的大二时的比赛。 问了可以实习的时间。 目前在学校里都学了什么课程。 面试官问我大四在做什么，我回答自己保研后在课题组里做结项的事情。面试官比较好奇我自己都做了什么，我回答东西都是别人做的，我就是提供一些辅助性的工作。 然后询问我课题组的主要研究是什么，我回答云计算，docker，k8s之类的。面试官问那为啥你做的东西和云计算一点关系都没有，又去做了算法NLP，我回答这是老师安排的。 问我对docker，k8s了解多少。我回答仅仅会简单的使用。 后来面试官解释NLP之类的工作一般是达摩院内边来做，意思可能是这边还是偏重于开发。 问我对这个部门的工作了解吗，一面有介绍吗？我回答和存储，预训练模型好像有关。 面试官说你要自己想好自己要做什么方向，兴趣是最好的老师啥的。（我也想啊） 面试官问我对NLP了解多少，我说仅仅毕业设计和这个有关，知道预训练和蒸馏。 他说感觉你对这些方面都有一点了解，但又都不深，不知道你将来要做什么。我回答自己目前还在探索，打算先开始做在去感受自己想要什么。 感觉聊到这里，其实已经无话可聊了。  下面是反问环节\n 我说自己可能问的问题比较大不好回答：如果我有机会得到这个offer，那我需要弥补的差距在什么地方？ 面试官从两个方面建议，一个就是如果计算想搞算法的话，blabla我忘了。如果想做开发的话，可以学习一下云原生，云计算之类的知识。 面试官分析了一下之后，我回答自己的理解与看法 ，主要说了人工智能是一种拿来应用的技术，做工程的过程中拿来使用，是工程的一部分。不是所有人都要去研究模型，我们能拿来即用即可，还是要去提升工程上的开发能力。  面试总结 我其实看不出来这次的结果好坏，面试官也确实提到了欢迎来去做一些尝试，可以先进来，实习的过程中摸索自己的兴趣，感受一下各个方向是什么样的，但更像是一些 说法正确的客套话。\n目前还在等结果。（希望结果是好的吧）\n","date":"2021-12-04T18:31:16+08:00","image":"https://img2.baidu.com/it/u=3334504742,937198599\u0026fm=26\u0026fmt=auto","permalink":"https://tweakzx.github.io/p/%E9%98%BF%E9%87%8C%E5%AE%9E%E4%B9%A0%E4%BA%8C%E9%9D%A2/","title":"阿里实习二面"},{"content":" 时间：2021-11-30 下午2点\n方式：阿里会议视频面试\n岗位：研究型实习生-智能存储\n 为什么会参加这次面试？ 因为想要亲身参与真实的科研活动或者一个真实企业内的做工程的过程，所以投递了这份简历，我也没有想到会给我安排面试。其实面试的时候我已经忘记自己投递的是哪个课题了，现在推测一下可能是大规模预训练模型的迁移啥的。\n因为面试的前一天参加了字节的面试，十分挫败，所以对面试可以说十分没有信心，加上收到的邮件里没有会议链接。无论面与不面，迟早要打电话告知，所以索性决定打电话推辞掉这个面试。打了电话，估计中午面试联系人可能在休息，所以过了一会才接到，面试联系人劝说我面试没有坏的影响，就当锻炼自己，只有好处没有坏处，不如一试。所以没有推脱，反正就一个小时，一个小时之后我的生活还会恢复原样。\n面试过程 面试的时候发现刚刚接电话的人应该就是面试官，面试官给我详细介绍了一下什么是研究型实习生以及它和其他的实习生的区别，以及对招聘的影响。然后就开始面试，先是自我介绍，还是介绍了本科，研究生的学校和专业，实习与比赛。问了我大概想做科研还是偏工程的方向，我回答工程，但后来想想应该回答我都行的其实。\n  面试了一道算法题：\n 将一个字符串按单词反转，但是对空间的开销有限制，最好是在原地址上直接修改，如果用栈，或者切割单词成数组之类的方式都是不符合空间开销要求的。\n 刚开始我想的是将单词先切出来，面试官发现我可能没有理解题目就又说了一下。\n我之后想说判断空格 然后做首尾交换，面试官提醒我单词的长度可能是不一致的，让我再想想。\n面试官说可以先说一下思路，再写代码。（说实话这点还挺赞的。）\n最后我想了想，说实话因为没有什么信心，我都想放弃算了。\n但偏偏还是想到了先把每个单词都先在局部反转，然后全局一起反转就不会产生大的空间开销。\n面试官说这个想法是对的，然后让我自己实现一下，就大概写了写代码。\n又问了我这个算法的时间复杂度是多少，我说是O(n)。\n  问平时怎么做测试，我回答用自己设计测试样例，然后print的方法和编辑器调试。\n他问我有么有用什么测试工具之类的，我说在课上学过UnitTest4，但实际上没用过。\n  知不知道多线程，pthread之类的。\n  之后聊了实习，实习时写的Json工具，日志接口开发。我都回答其实没有什么含金量。\n  然后是机器人大赛，路径规划算法用的是A* ,问我为什么用A* 而不是用机器人走迷宫的方式来操控机器人。和视觉算法的设计，以及OpenCV啥的。\n  最后聊了本科毕设，介绍了自己的毕设内容，问我觉得最有挑战的部分是啥。我回答是loss函数的设计，三段蒸馏，每段的不同的损失计算方法。\n  然后就是反问环节，我没问，确实不知道问啥。\n面试总结 大概就只记得这些了，好像忘记了很多其他的细节，但是面试完心情也比之前好了一些。\n阿里巴巴的这次面试给我最大的感受就是，面试官会确认自己的意思有没有准确传达给我，这个细节还挺令我感动的。面试官会把自己的问题或者很多要考虑的情况讲的很细致，确认我理解之后再让我思考并回答，这样其实对我这样不太熟悉面试的人十分友好的。\n面试的结果还不知道，但是无论好与坏，这次面试都给了我一些鼓舞，即便是结果不太好，我也不会气馁，不管怎么样都要继续努力。（希望结果是好的吧）\n后来接到了二面的电话，所以一面应该是过了。\n","date":"2021-12-01T21:49:57+08:00","image":"https://img2.baidu.com/it/u=3334504742,937198599\u0026fm=26\u0026fmt=auto","permalink":"https://tweakzx.github.io/p/%E9%98%BF%E9%87%8C%E7%A0%94%E7%A9%B6%E5%9E%8B%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95/","title":"阿里研究型实习生面试"},{"content":" 时间：2021-11-26 下午六点\n方式：飞书视频面试\n岗位：后端开发\n 为什么会面试蓝湖 心血来潮想要出去实习，在校友群内发了求助。24号中午，本科的同班同学涛神问我想不想试一试蓝湖，我想要一份实习来提升自己的代码水平，所以当然要抓住这次机会。\n所以中午抓紧时间写了一份简历交给了涛神帮忙内推。涛神问我要不要先准备一下，我说不了，早解决早轻松，可能是犯蠢了，也可能是太了解自己，我不是会好好规划复习的人，所以不如趁着热情直接上。\n面试的过程 面试官还是很温柔的，上来先让我做了一下自我介绍，我介绍了一下本科和硕士，以及一段实习经历，一段比赛经历。让说一下觉得最有有挑战性的工作？实习和比赛都很水，所以实话实说没啥亮点。\n算法题一道，写一下快排。当时代码没有跑起来，因为vscode好像更新了code runner的配置，所以没有跑起来，不过写的代码大概率全是bug，代码能力也是硬伤。\nclass Solution { public: int qsort(vector\u0026lt;int\u0026gt;\u0026amp; nums,int left,int right){ int l = left; int r = right; if(l\u0026gt;=r){ return l; } int randNum = rand()%(r-l+1)+l; int temp = nums[randNum]; nums[randNum] = nums[l]; nums[l] = temp; int pivot = nums[l]; while(l\u0026lt;r){ while(l\u0026lt;r\u0026amp;\u0026amp;nums[r]\u0026gt;pivot){ r--; } nums[l] = nums[r]; while(l\u0026lt;r\u0026amp;\u0026amp;nums[l]\u0026lt;=pivot){ l++; } nums[r] = nums[l]; } nums[l] = pivot; qsort(nums,left,l-1); qsort(nums,l+1,right); return l; } vector\u0026lt;int\u0026gt; sortArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { srand((unsigned)time(NULL)); qsort(nums,0,(int)nums.size()-1); return nums; } }; 然后问了一些基础问题：\n  Java和C++的区别有哪些\n  类的重写和重载\n  TCP通信的三次握手和四次挥手，为什么不能多一次或者少一次？\n  TCP长连接和短链接\n  TCP和UDP的区别\n  了解Cache吗？我答非所问，回答了操作系统的cache。\n  其实有可能是问http缓存\n  输入url地址浏览器的变化\n  问有么有用过数据库，对数据库了解多少，回答用过MySQL\n  为什么要用数据库？\n  简单介绍一下云计算是什么，为什么要用云计算\n  面试总结 面完就知道自己应该是凉了，果然12月1号收到了感谢信。其实还是老问题，自己的基础知识还是要在巩固一下可能要多看看面经，另外算法什么的还是要多加练习。\n后来涛神告诉我是HR觉得只有一个月多的实习时间太短了，不好安排。\n","date":"2021-12-01T20:56:54+08:00","image":"https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/image-20211201214555354.png","permalink":"https://tweakzx.github.io/p/%E8%93%9D%E6%B9%96%E9%9D%A2%E8%AF%95%E5%87%89%E7%BB%8F/","title":"蓝湖面试凉经"},{"content":" 时间：2021-11-29下午三点\n方式：飞书视频面试\n岗位：后端开发实习生-业务中台职位\n 为什么会投递字节实习 ​\t因为中科院的研究所大多不让实习，研二想去实习是一定不行的。但是研一在雁栖湖，课题组在海淀，我研一基本不参与科研，所以想要趁没人管的时候出去实习。因为将来大概率是做软开，所以想找一份后端开发的工作。在校友群里问了一下，有学长给了一个内推的机会，所以就有了这次一面。\n面试过程 ​\t面试官上来让我做了自我介绍之后就让我写代码做题。\n 题目一：链表1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6 转变成 链表1-\u0026gt;6-\u0026gt;2-\u0026gt;5-\u0026gt;3-\u0026gt;4\n大概意思就是将链表平分成两部分，前一部分顺序不变，后一部分反转后插空插入前一部分链表。\n ​\t说实话，自己的代码能力确实有点差，原本打算使用c++来写后来改成了Java，因为我想起Java里有LinkedList这个数据结构。理由有点荒诞哈，其实是我没有意识到要自己定义节点来实现链表，所以在想要写指针的时候就卡住了，完全不知道怎么给LinkedList的链表写指针。然后就尬住了，面试官无奈说那就换一道吧。\n 题目二：判断一个二叉树是否是平衡树\n ​\t题目不是很难，但是自己太久不写代码有些生疏了，写出来的程序不知道为什么没有编译通过。说实话，面试官让我自己实现一个单例来测试程序，其中爆出的各种错误，无一不揭示了我完全没有什么开发经验的事实，例如内部类放错了位置，static的编译问题，还有一个空指针异常。无疑是再次尬死了。\n​\t之后面试官让我讲一讲自己的项目经历，主要问了一下大三在华为的实习。可惜自己虽然实习了，但实际的工作很少，含金量也不高，面试官兴趣不大。\n​\t之后就是问我有没有什么想问他的，我已经不想说话了，就没问。\n​\t草草结束。\n总结 首先还是把这两道题的代码写写吧 题目一 /** * @author lizhixuan * @version 1.0 * @date 2021/12/1 15:50 */ public class ReverseList2 { public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode createInstance(int n){ ListNode head = new ListNode(1); ListNode current = head; for (int i = 2; i \u0026lt;= n; i++) { current.next = new ListNode(i); current = current.next; } return head; } public static void printList(ListNode head){ ListNode current = head; while(current.next!=null){ System.out.print(current.val); System.out.print(\u0026#34;-\u0026gt;\u0026#34;); current = current.next; } System.out.println(current.val); } public static ListNode reverse(ListNode head){ ListNode pre = null; ListNode current = head; ListNode next; while(current!=null){ next = current.next; current.next = pre; pre = current; current = next; } return pre; } public static ListNode mergeList(ListNode l1,ListNode l2){ ListNode head = l1; ListNode l1Next; ListNode l2Next; while(l1!=null\u0026amp;\u0026amp;l2!=null){ l1Next = l1.next; l2Next = l2.next; l1.next = l2; l2.next = l1Next; l1 = l1Next; l2 = l2Next; } return head; } public static ListNode reverseHalf(ListNode head){ ListNode fast = head; ListNode slow = head; while(fast != null){ if(fast.next == null){ break; } if(fast.next.next == null){ break; } fast = fast.next.next; slow = slow.next; } ListNode half = reverse(slow.next); slow.next = null; return mergeList(head,half); } public static void main(String[] args) { ListNode head = createInstance(7); printList(head); head = reverseHalf(head); printList(head); } } 题目二 import java.util.LinkedList; import java.util.Queue; /** * @author lizhixuan * @version 1.0 * @date 2021/12/1 17:24 */ public class BalanceCheck { public static class TreeNode{ int val; TreeNode left; TreeNode right; TreeNode(int val){this.val = val;} } public static TreeNode listToTree(String src){ src = src.substring(1,src.length()-1); String[] strList = src.split(\u0026#34;,\u0026#34;); TreeNode root ; TreeNode result = null; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i =0 ; i\u0026lt; strList.length ; i++){ if (i == 0){ root = new TreeNode(Integer.parseInt(strList[i])); result = root; queue.add(root); } if (!queue.isEmpty()){ root = queue.poll(); }else { break; } if ( i+1 \u0026lt; strList.length \u0026amp;\u0026amp; !strList[i+1].equals( \u0026#34;null\u0026#34;)){ root.left = new TreeNode(Integer.parseInt(strList[i +1])); queue.add(root.left); } if ( i + 2 \u0026lt; strList.length \u0026amp;\u0026amp; !strList[i+2].equals( \u0026#34;null\u0026#34;)){ root.right = new TreeNode(Integer.parseInt(strList[i +2])); queue.add(root.right); } i = i +1; } return result; } public static int getHeight(TreeNode root){ if(root==null){ return 0; } return Math.max(getHeight(root.left),getHeight(root.right))+1; } public static boolean isBalanced(TreeNode root){ if(root==null){ return true; } int leftHeight = getHeight(root.left); int rightHeight = getHeight(root.right); return Math.abs(leftHeight-rightHeight)\u0026lt;=1 \u0026amp;\u0026amp; isBalanced(root.left) \u0026amp;\u0026amp; isBalanced(root.right); } public static void main(String[] args) { String tree = \u0026#34;[3,9,20,null,null,15,7]\u0026#34;; TreeNode root = listToTree(tree); System.out.println(isBalanced(root)); } } 一些知识点   java内部类：\n 成员内部类中不能存在任何static的变量和方法 成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类    java的static关键字\n static变量也称作静态变量，静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。 为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。 在C/C++中static是可以作用域局部变量的，但是在Java中切记：static是不允许用来修饰局部变量。    反思  自己还是缺乏代码经验，代码写不出来，面试官明显十分失望，失去耐心之后多次叹气捂脸，说实话压力还是挺大的，毕竟确实挺丢脸的。以后也要多写一点代码。 打算把自己的学习总结下来，于是也有了这篇博客，希望自己可以坚持写博客，说实话，面试完压力挺大，感觉自己就是一个无敌铁废物，写博客写出来感觉好一些了。  ","date":"2021-11-29T16:52:26+08:00","image":"https://cdn.jsdelivr.net/gh/Tweakzx/ImageHost@main/img/bytedance.jpg","permalink":"https://tweakzx.github.io/p/%E5%AD%97%E8%8A%82%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E5%87%89%E7%BB%8F/","title":"字节实习面试凉经"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://tweakzx.github.io/p/%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83/","title":"安装环境"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://tweakzx.github.io/p/%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83/","title":"安装环境"}]