<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Tweakzx</title>
    <link>https://tweakzx.github.io/post/</link>
    <description>Recent content in Posts on Tweakzx</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 13 Jun 2022 14:57:42 +0800</lastBuildDate><atom:link href="https://tweakzx.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ubuntu安装k8s集群</title>
      <link>https://tweakzx.github.io/p/ubuntu%E5%AE%89%E8%A3%85k8s%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Mon, 13 Jun 2022 14:57:42 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/ubuntu%E5%AE%89%E8%A3%85k8s%E9%9B%86%E7%BE%A4/</guid>
      <description>在ubuntu上搭建k8s集群 一、机器配置 配置主机名 sudo hostnamectl set-hostname &amp;#34;k8s-master&amp;#34; // Run this command on masternode cat /etc/hostname sudo hostnamectl set-hostname &amp;#34;k8s-node1&amp;#34; // Run this command on node-0 sudo hostnamectl set-hostname &amp;#34;k8s-node2&amp;#34; // Run this command on node-1 配置/etc/hosts sudo vi /etc/hosts 10.1.13.106 k8s-master #10.1.13.107 k8s-node1 #10.1.13.108 k8s-node1 配置免密登录 想让机器 A 访问机器 B，就把机器 A 的公钥放到机器 B 的~/.ssh/authorized_keys 文件里就行了。
首先我们在worker上生成一个密钥，输入下述命令后一路回车即可：
ssh-keygen 然后登录master，并依次输入下述两条命令将其复制并写入到master的authorized_keys中，注意我下面的scp命令中使用了worker别名，要提前进行配置：
# 复制到 master 主机 scp root@worker:~/.ssh/id_rsa.pub /home # 写入到 authorized_keys 中 cat /home/id_rsa.</description>
    </item>
    
    <item>
      <title>centOS安装环境</title>
      <link>https://tweakzx.github.io/p/centos%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 28 Apr 2022 13:36:00 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/centos%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83/</guid>
      <description>安装 git yum install git 安装 docker curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun systemctl start docker 安装 make yum -y install gcc automake autoconf libtool make yum install gcc gcc-c++ 安装 K8s curl -LO &amp;#34;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl&amp;#34; curl -LO &amp;#34;https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256&amp;#34; echo &amp;#34;$(cat kubectl.sha256)kubectl&amp;#34; | sha256sum --check sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl kubectl version --client 安装 go   Remove any previous Go installation  by deleting the /usr/local/go folder (if it exists), then extract the archive you just downloaded into /usr/local, creating a fresh Go tree in /usr/local/go:</description>
    </item>
    
    <item>
      <title>自动机的实现</title>
      <link>https://tweakzx.github.io/p/%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 12 Mar 2022 16:59:39 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>题目描述 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。
函数 myAtoi(string s) 的算法如下：
 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，&amp;ldquo;123&amp;rdquo; -&amp;gt; 123， &amp;ldquo;0032&amp;rdquo; -&amp;gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。  注意：
  本题中的空白字符只包括空格字符 &#39; &#39; 。
  除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。
  示例 1：
 输入：s = &amp;ldquo;42&amp;rdquo; 输出：42 解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。 第 1 步：&amp;ldquo;42&amp;rdquo;（当前没有读入字符，因为没有前导空格） ^ 第 2 步：&amp;ldquo;42&amp;rdquo;（当前没有读入字符，因为这里不存在 &amp;lsquo;-&amp;rsquo; 或者 &amp;lsquo;+&#39;） ^ 第 3 步：&amp;ldquo;42&amp;rdquo;（读入 &amp;ldquo;42&amp;rdquo;） ^ 解析得到整数 42 。 由于 &amp;ldquo;42&amp;rdquo; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</description>
    </item>
    
    <item>
      <title>Go语言之旅</title>
      <link>https://tweakzx.github.io/p/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/</link>
      <pubDate>Tue, 22 Feb 2022 17:20:32 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/</guid>
      <description>旅行起点 Go 语言之旅 (go-zh.org)
上方链接是一个Go语言学习的Playground，快点击它，开启一场Go语言之旅吧
旅行开始 练习：循环与函数 为了练习函数与循环，我们来实现一个平方根函数：用牛顿法实现平方根函数。
计算机通常使用循环来计算 x 的平方根。从某个猜测的值 z 开始，我们可以根据 z² 与 x 的近似度来调整 z，产生一个更好的猜测：
z -= (z*z - x) / (2*z) 重复调整的过程，猜测的结果会越来越精确，得到的答案也会尽可能接近实际的平方根。
在提供的 func Sqrt 中实现它。无论输入是什么，对 z 的一个恰当的猜测为 1。 要开始，请重复计算 10 次并随之打印每次的 z 值。观察对于不同的值 x（1、2、3 &amp;hellip;）， 你得到的答案是如何逼近结果的，猜测提升的速度有多快。
提示：用类型转换或浮点数语法来声明并初始化一个浮点数值：
z := 1.0 z := float64(1) 然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数大于还是小于 10。 尝试改变 z 的初始猜测，如 x 或 x/2。你的函数结果与标准库中的 math.Sqrt 接近吗？
（注： 如果你对该算法的细节感兴趣，上面的 z² − x 是 z² 到它所要到达的值（即 x）的距离， 除以的 2z 为 z² 的导数，我们通过 z² 的变化速度来改变 z 的调整量。 这种通用方法叫做牛顿法。 它对很多函数，特别是平方根而言非常有效。）</description>
    </item>
    
    <item>
      <title>PolarDB Serverless论文阅读报告</title>
      <link>https://tweakzx.github.io/p/polardb-serverless%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A/</link>
      <pubDate>Wed, 22 Dec 2021 14:17:12 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/polardb-serverless%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A/</guid>
      <description>PolarDB Serverless论文阅读报告 摘要 数据库管理系统的上云是近期很火的研究趋势，因为这样可以获得更高的弹性，可用性以及更低的成本，传统的独块的数据库架构很难满足这样的要求。高速网络与新的内存技术（例如RDMA）的发展，给分散式数据库带来了可能：它将原先的独块的服务器资源分离解耦到资源池中，再通过高速网络连接起来。下一代的云原生数据库就是为了分散化的数据中心而设计。
PolarDB Serverless 遵循分散式的设计范式而设计，解耦了计算节点的CPU，内存，存储资源。
 每种资源可以随需求而独立的增长或缩小，保障可靠性的同时，可以进行多维度的按需供应。 同时采用了优化策略如乐观锁和预取策略来改善性能。 还可以实现更快的故障恢复。  介绍 使用云数据库的三个好处：  按需付费可以使得用户减小开支。 更高的资源弹性可以应对短暂的资源使用高峰期。 更快的升级与更快的错误修复。快速的升级迭代可以保证产品竞争力，错误修复可以在不影响产品可用性的前提下进行。  经典的云数据库的架构  monolithic machine 独块的机器  特点：所有的资源都是紧耦合的 问题：  在进行数据库实例到机器的分发过程中要解决一个装箱问题 总是有碎片化的资源，难以达到高的使用率 运行时不能根据负载调整资源 资源间的命运共享，一个资源的故障会导致其他资源的故障，不能独立透明地修复故障，导致修复时间很长     存算分离的架构：  两种：  virtual machine with remote disk 搭载远程硬盘的虚拟机 shared storage 共享存储   优点  DBaaS可以提高存储池的使用率 共享存储可以进一步减少成本：原数据与只读备份可以共享存储   问题  CPU和内存的装箱问题依旧存在 缺乏灵活可放缩的内存资源 每个只读备份在内存中都要有冗余的内存开销      本文提出了一种新架构，分散架构（disaggragation architecture)  运行在分散的数据中心（DDC），CPU、内存和存储解耦，资源间通过高速网络连接 效果  每一种资源都可以提高其利用率，可以独立地放缩其资源量 解决了资源间的命运共享问题，资源故障可以被独立修复 数据页可以在远程内存池中被共享，所以解决了备份的内存冗余问题    云原生数据库 多数的云数据库是基于共享存储的架构，内存和CPU绑成最小的资源单元，只能按照最小资源单元的粒度来增长和释放资源，这会带来很多的资源浪费。</description>
    </item>
    
    <item>
      <title>并行作业 3</title>
      <link>https://tweakzx.github.io/p/%E5%B9%B6%E8%A1%8C%E4%BD%9C%E4%B8%9A-3/</link>
      <pubDate>Tue, 14 Dec 2021 13:55:35 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/%E5%B9%B6%E8%A1%8C%E4%BD%9C%E4%B8%9A-3/</guid>
      <description>1 HPL（High Performance Linpack) 假设要使用HPL程序在4个进程上解一个4096 * 4096的方程组（4096 * 4096的矩阵加一列方程组的右端项b），按照讲义第14页所示的block-cyclic方式对数据进行分配，NB=512。4个进程按1 * 4和4 * 1两种方式排布。那么，在HPL的回代部分（讲义48到55页），X的各个元素分别是由哪些进程算出的？例如，X[0..512]由进程(3, 0)求出。写出两种排布方式下X的各部分分别由哪些进程计算得到。（5分）
 1 * 4 排布  image-20211214170301242
   X 进程     X[0..511] (0,0)   X[512..1023] (0,1)   X[1024..1535] (0,2)   X[1536..2047] (0,3)   X[2048..2559] (0,0)   X[2560..3071] (0,1)   X[3072..3583] (0,2)   X[3584..4095] (0,3)     4 * 1 排布  image-20211214170325158</description>
    </item>
    
    <item>
      <title>CUDA加速课程题目</title>
      <link>https://tweakzx.github.io/p/cuda%E5%8A%A0%E9%80%9F%E8%AF%BE%E7%A8%8B%E9%A2%98%E7%9B%AE/</link>
      <pubDate>Mon, 13 Dec 2021 19:03:20 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/cuda%E5%8A%A0%E9%80%9F%E8%AF%BE%E7%A8%8B%E9%A2%98%E7%9B%AE/</guid>
      <description>1 加速向量加法 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;assert.h&amp;gt; inline cudaError_t checkCuda(cudaError_t result) { if (result != cudaSuccess) { fprintf(stderr, &amp;#34;CUDA Runtime Error: %s\n&amp;#34;, cudaGetErrorString(result)); assert(result == cudaSuccess); } return result; } void initWith(float num, float *a, int N) { for(int i = 0; i &amp;lt; N; ++i) { a[i] = num; } } __global__ void addVectorsInto(float *result, float *a, float *b, int N) { int initIndex = threadIdx.x + blockIdx.x * blockDim.x; int gridStride = gridDim.</description>
    </item>
    
    <item>
      <title>并行作业 2</title>
      <link>https://tweakzx.github.io/p/%E5%B9%B6%E8%A1%8C%E4%BD%9C%E4%B8%9A-2/</link>
      <pubDate>Sat, 11 Dec 2021 18:01:26 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/%E5%B9%B6%E8%A1%8C%E4%BD%9C%E4%B8%9A-2/</guid>
      <description>1 矩阵向量乘法（6分） 矩阵向量乘法(gemv)如何用OpenMP或pthread对其并行化(OpenMP和pthread任选一种即可)？假设矩阵按行存储（每一行数据是连续的），处理器有32个核。如果矩阵是按列存储呢？具体实现如何修改？
可用语言详细描述或写出伪代码
  按行存储
void *worker1(int row, int N, int** A, int* vec, int* result){ for(int i = row; i&amp;lt;N; i += 32){ result[i] = innerProduct(A[i],Vec); } } int main(){ ... for(int i=0;i&amp;lt;32;i++){ data_array[i].row = i; pthread_create(&amp;amp;threads[i], NULL, worker1, (void *)&amp;amp;data_array[i]) } ... }   按列存储
void *worker2(int column, int N, int M, int** A, int* vec, int* result){ for(int j = column; j&amp;lt;M; j += 32){ for(int i = 0; i&amp;lt;N; i++){ result[i] += A[j][i]*Vec[j]; } } } int main(){ .</description>
    </item>
    
    <item>
      <title>并行作业 1</title>
      <link>https://tweakzx.github.io/p/%E5%B9%B6%E8%A1%8C%E4%BD%9C%E4%B8%9A-1/</link>
      <pubDate>Fri, 10 Dec 2021 11:28:33 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/%E5%B9%B6%E8%A1%8C%E4%BD%9C%E4%B8%9A-1/</guid>
      <description>1矩阵向量乘法（4分） 讲义55页所示结果Y，如果要作为下一次矩阵向量乘法的输入X，切分到不同的列进程，并且复制到每一行进程，应如何操作？可写出伪代码，或用语言描述。
即图(a)中的Y，变成下图(b)中的X。假设每行有P个进程，每列也是P个进程，一共P*P个进程。
image-20211210120943046
答：进程$P_{ij}$和所控制的矩阵进行矩阵向量乘之后，将结果存入进程$P_{ji}$。
2 代码填空（3分） 在测量程序性能时，我们经常要记录整个程序或程序中某一部分的运行时间。在MPI程序中，由于每个进程的运行时间不同，一般需要取各个进程运行时间的最大值，然后由0号进程保存和打印（其他进程不需要保存）。以下程序完成了这个功能，请在横线处填上函数调用语句。
int main(int argc, char * argv) { double total_time; double time0, time1; int procs, rank; MPI_init(argc, argv); MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;procs); MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;rank); time0 = MPI_Wtime(); //do some computation 	time1 = MPI_Wtime() – time0; _______________________________________________________________ if(rank == 0) { Printf(“Total execution time is %f seconds\n”, total_time); } } 答：
MPI_Reduce(&amp;amp;time1,&amp;amp;total_time,1,MPI_DOUBLE,MPI_MAX,0,MPI_COMM_WORLD) 3 以下程序相当于哪个MPI聚合操作？（3分） #define N 16384 double *send_buff, *recv_buff; MPI_Status status; int i, nprocs, myid, count=N/num_procs; send_buff = (double*)malloc(N*sizeof(double)); recv_buff = (double*)malloc(N*sizeof(double)); MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;nprocs); MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;myid); //此处省略send_buff中数据的初始化 memcpy((void*)(recv_buff + myid * count), (void*)(send_buff + myid * count), count*sizeof(double)); for(int i = 0; i &amp;lt; nprocs;i++) { if(i!</description>
    </item>
    
    <item>
      <title>分布式巩固类作业</title>
      <link>https://tweakzx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A9%E5%9B%BA%E7%B1%BB%E4%BD%9C%E4%B8%9A/</link>
      <pubDate>Tue, 07 Dec 2021 14:21:24 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A9%E5%9B%BA%E7%B1%BB%E4%BD%9C%E4%B8%9A/</guid>
      <description>1 逻辑时钟与一致割集 下图中，直线上小黑点给出了时钟计数，请分别用Lamport 逻辑时钟和向量时钟给图上的事件设置时间戳，并给出一致割集和非一致割集的例子。
事件时钟计数
答：
  设置时间戳
  Lamport逻辑时钟
Lamport逻辑时钟
  向量时钟
向量时钟
    割集的例子
  一致割集
一致割集
  非一致割集
非一致割集
包含$e_1^2$这个接收事件但是不包含$e_3^1$这个发送事件。
    2 异步分布式系统的故障类型 考虑在异步分布式系统中使用的两个通信服务。在服务A中，消息可能丢失、被复制或延迟，校验和仅应用到消息头。在服务B中，消息可能丢失、延迟或发送地太快以致接收方无法处理它，但到达目的地的消息其内容一定正确。描述每个服务会有的故障类型。根据对有效性和完整性的影响将故障分类。服务B能被描述成一个可靠的通信服务吗？
答：
  服务A会有的故障类型
 遗漏故障  消息丢失   拜占庭故障  checksum仅仅应用到消息的head，消息的body可能发生损坏 消息重复   因为这是异步分布式系统，所以不会有时序故障。  遗漏故障的消息丢失破坏了有效性。拜占庭故障的可能损坏的消息以及重复的消息破坏了完整性。
  服务B会有的故障类型</description>
    </item>
    
    <item>
      <title>阿里实习二面</title>
      <link>https://tweakzx.github.io/p/%E9%98%BF%E9%87%8C%E5%AE%9E%E4%B9%A0%E4%BA%8C%E9%9D%A2/</link>
      <pubDate>Sat, 04 Dec 2021 18:31:16 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/%E9%98%BF%E9%87%8C%E5%AE%9E%E4%B9%A0%E4%BA%8C%E9%9D%A2/</guid>
      <description>时间：2021-12-2 下午5点半
方式：阿里会议视频面试
岗位：研究型实习生-智能存储
 面试过程 这次面试主要是在聊项目，聊兴趣啥的。没有什么算法或者知识点的提问。
 先做一下自我介绍。 问我觉得自己在学习上的最大优势是什么。 问我大三实习的主要工作，这一部分我还是忽略的带过了。 讲了自己的大二时的比赛。 问了可以实习的时间。 目前在学校里都学了什么课程。 面试官问我大四在做什么，我回答自己保研后在课题组里做结项的事情。面试官比较好奇我自己都做了什么，我回答东西都是别人做的，我就是提供一些辅助性的工作。 然后询问我课题组的主要研究是什么，我回答云计算，docker，k8s之类的。面试官问那为啥你做的东西和云计算一点关系都没有，又去做了算法NLP，我回答这是老师安排的。 问我对docker，k8s了解多少。我回答仅仅会简单的使用。 后来面试官解释NLP之类的工作一般是达摩院内边来做，意思可能是这边还是偏重于开发。 问我对这个部门的工作了解吗，一面有介绍吗？我回答和存储，预训练模型好像有关。 面试官说你要自己想好自己要做什么方向，兴趣是最好的老师啥的。（我也想啊） 面试官问我对NLP了解多少，我说仅仅毕业设计和这个有关，知道预训练和蒸馏。 他说感觉你对这些方面都有一点了解，但又都不深，不知道你将来要做什么。我回答自己目前还在探索，打算先开始做在去感受自己想要什么。 感觉聊到这里，其实已经无话可聊了。  下面是反问环节
 我说自己可能问的问题比较大不好回答：如果我有机会得到这个offer，那我需要弥补的差距在什么地方？ 面试官从两个方面建议，一个就是如果计算想搞算法的话，blabla我忘了。如果想做开发的话，可以学习一下云原生，云计算之类的知识。 面试官分析了一下之后，我回答自己的理解与看法 ，主要说了人工智能是一种拿来应用的技术，做工程的过程中拿来使用，是工程的一部分。不是所有人都要去研究模型，我们能拿来即用即可，还是要去提升工程上的开发能力。  面试总结 我其实看不出来这次的结果好坏，面试官也确实提到了欢迎来去做一些尝试，可以先进来，实习的过程中摸索自己的兴趣，感受一下各个方向是什么样的，但更像是一些 说法正确的客套话。
目前还在等结果。（希望结果是好的吧）</description>
    </item>
    
    <item>
      <title>阿里研究型实习生面试</title>
      <link>https://tweakzx.github.io/p/%E9%98%BF%E9%87%8C%E7%A0%94%E7%A9%B6%E5%9E%8B%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Wed, 01 Dec 2021 21:49:57 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/%E9%98%BF%E9%87%8C%E7%A0%94%E7%A9%B6%E5%9E%8B%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95/</guid>
      <description>时间：2021-11-30 下午2点
方式：阿里会议视频面试
岗位：研究型实习生-智能存储
 为什么会参加这次面试？ 因为想要亲身参与真实的科研活动或者一个真实企业内的做工程的过程，所以投递了这份简历，我也没有想到会给我安排面试。其实面试的时候我已经忘记自己投递的是哪个课题了，现在推测一下可能是大规模预训练模型的迁移啥的。
因为面试的前一天参加了字节的面试，十分挫败，所以对面试可以说十分没有信心，加上收到的邮件里没有会议链接。无论面与不面，迟早要打电话告知，所以索性决定打电话推辞掉这个面试。打了电话，估计中午面试联系人可能在休息，所以过了一会才接到，面试联系人劝说我面试没有坏的影响，就当锻炼自己，只有好处没有坏处，不如一试。所以没有推脱，反正就一个小时，一个小时之后我的生活还会恢复原样。
面试过程 面试的时候发现刚刚接电话的人应该就是面试官，面试官给我详细介绍了一下什么是研究型实习生以及它和其他的实习生的区别，以及对招聘的影响。然后就开始面试，先是自我介绍，还是介绍了本科，研究生的学校和专业，实习与比赛。问了我大概想做科研还是偏工程的方向，我回答工程，但后来想想应该回答我都行的其实。
  面试了一道算法题：
 将一个字符串按单词反转，但是对空间的开销有限制，最好是在原地址上直接修改，如果用栈，或者切割单词成数组之类的方式都是不符合空间开销要求的。
 刚开始我想的是将单词先切出来，面试官发现我可能没有理解题目就又说了一下。
我之后想说判断空格 然后做首尾交换，面试官提醒我单词的长度可能是不一致的，让我再想想。
面试官说可以先说一下思路，再写代码。（说实话这点还挺赞的。）
最后我想了想，说实话因为没有什么信心，我都想放弃算了。
但偏偏还是想到了先把每个单词都先在局部反转，然后全局一起反转就不会产生大的空间开销。
面试官说这个想法是对的，然后让我自己实现一下，就大概写了写代码。
又问了我这个算法的时间复杂度是多少，我说是O(n)。
  问平时怎么做测试，我回答用自己设计测试样例，然后print的方法和编辑器调试。
他问我有么有用什么测试工具之类的，我说在课上学过UnitTest4，但实际上没用过。
  知不知道多线程，pthread之类的。
  之后聊了实习，实习时写的Json工具，日志接口开发。我都回答其实没有什么含金量。
  然后是机器人大赛，路径规划算法用的是A* ,问我为什么用A* 而不是用机器人走迷宫的方式来操控机器人。和视觉算法的设计，以及OpenCV啥的。
  最后聊了本科毕设，介绍了自己的毕设内容，问我觉得最有挑战的部分是啥。我回答是loss函数的设计，三段蒸馏，每段的不同的损失计算方法。
  然后就是反问环节，我没问，确实不知道问啥。
面试总结 大概就只记得这些了，好像忘记了很多其他的细节，但是面试完心情也比之前好了一些。
阿里巴巴的这次面试给我最大的感受就是，面试官会确认自己的意思有没有准确传达给我，这个细节还挺令我感动的。面试官会把自己的问题或者很多要考虑的情况讲的很细致，确认我理解之后再让我思考并回答，这样其实对我这样不太熟悉面试的人十分友好的。
面试的结果还不知道，但是无论好与坏，这次面试都给了我一些鼓舞，即便是结果不太好，我也不会气馁，不管怎么样都要继续努力。（希望结果是好的吧）
后来接到了二面的电话，所以一面应该是过了。</description>
    </item>
    
    <item>
      <title>蓝湖面试凉经</title>
      <link>https://tweakzx.github.io/p/%E8%93%9D%E6%B9%96%E9%9D%A2%E8%AF%95%E5%87%89%E7%BB%8F/</link>
      <pubDate>Wed, 01 Dec 2021 20:56:54 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/%E8%93%9D%E6%B9%96%E9%9D%A2%E8%AF%95%E5%87%89%E7%BB%8F/</guid>
      <description>时间：2021-11-26 下午六点
方式：飞书视频面试
岗位：后端开发
 为什么会面试蓝湖 心血来潮想要出去实习，在校友群内发了求助。24号中午，本科的同班同学涛神问我想不想试一试蓝湖，我想要一份实习来提升自己的代码水平，所以当然要抓住这次机会。
所以中午抓紧时间写了一份简历交给了涛神帮忙内推。涛神问我要不要先准备一下，我说不了，早解决早轻松，可能是犯蠢了，也可能是太了解自己，我不是会好好规划复习的人，所以不如趁着热情直接上。
面试的过程 面试官还是很温柔的，上来先让我做了一下自我介绍，我介绍了一下本科和硕士，以及一段实习经历，一段比赛经历。让说一下觉得最有有挑战性的工作？实习和比赛都很水，所以实话实说没啥亮点。
算法题一道，写一下快排。当时代码没有跑起来，因为vscode好像更新了code runner的配置，所以没有跑起来，不过写的代码大概率全是bug，代码能力也是硬伤。
class Solution { public: int qsort(vector&amp;lt;int&amp;gt;&amp;amp; nums,int left,int right){ int l = left; int r = right; if(l&amp;gt;=r){ return l; } int randNum = rand()%(r-l+1)+l; int temp = nums[randNum]; nums[randNum] = nums[l]; nums[l] = temp; int pivot = nums[l]; while(l&amp;lt;r){ while(l&amp;lt;r&amp;amp;&amp;amp;nums[r]&amp;gt;pivot){ r--; } nums[l] = nums[r]; while(l&amp;lt;r&amp;amp;&amp;amp;nums[l]&amp;lt;=pivot){ l++; } nums[r] = nums[l]; } nums[l] = pivot; qsort(nums,left,l-1); qsort(nums,l+1,right); return l; } vector&amp;lt;int&amp;gt; sortArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { srand((unsigned)time(NULL)); qsort(nums,0,(int)nums.</description>
    </item>
    
    <item>
      <title>字节实习面试凉经</title>
      <link>https://tweakzx.github.io/p/%E5%AD%97%E8%8A%82%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E5%87%89%E7%BB%8F/</link>
      <pubDate>Mon, 29 Nov 2021 16:52:26 +0800</pubDate>
      
      <guid>https://tweakzx.github.io/p/%E5%AD%97%E8%8A%82%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E5%87%89%E7%BB%8F/</guid>
      <description>时间：2021-11-29下午三点
方式：飞书视频面试
岗位：后端开发实习生-业务中台职位
 为什么会投递字节实习 ​	因为中科院的研究所大多不让实习，研二想去实习是一定不行的。但是研一在雁栖湖，课题组在海淀，我研一基本不参与科研，所以想要趁没人管的时候出去实习。因为将来大概率是做软开，所以想找一份后端开发的工作。在校友群里问了一下，有学长给了一个内推的机会，所以就有了这次一面。
面试过程 ​	面试官上来让我做了自我介绍之后就让我写代码做题。
 题目一：链表1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6 转变成 链表1-&amp;gt;6-&amp;gt;2-&amp;gt;5-&amp;gt;3-&amp;gt;4
大概意思就是将链表平分成两部分，前一部分顺序不变，后一部分反转后插空插入前一部分链表。
 ​	说实话，自己的代码能力确实有点差，原本打算使用c++来写后来改成了Java，因为我想起Java里有LinkedList这个数据结构。理由有点荒诞哈，其实是我没有意识到要自己定义节点来实现链表，所以在想要写指针的时候就卡住了，完全不知道怎么给LinkedList的链表写指针。然后就尬住了，面试官无奈说那就换一道吧。
 题目二：判断一个二叉树是否是平衡树
 ​	题目不是很难，但是自己太久不写代码有些生疏了，写出来的程序不知道为什么没有编译通过。说实话，面试官让我自己实现一个单例来测试程序，其中爆出的各种错误，无一不揭示了我完全没有什么开发经验的事实，例如内部类放错了位置，static的编译问题，还有一个空指针异常。无疑是再次尬死了。
​	之后面试官让我讲一讲自己的项目经历，主要问了一下大三在华为的实习。可惜自己虽然实习了，但实际的工作很少，含金量也不高，面试官兴趣不大。
​	之后就是问我有没有什么想问他的，我已经不想说话了，就没问。
​	草草结束。
总结 首先还是把这两道题的代码写写吧 题目一 /** * @author lizhixuan * @version 1.0 * @date 2021/12/1 15:50 */ public class ReverseList2 { public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.</description>
    </item>
    
  </channel>
</rss>
